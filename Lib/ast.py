"""
    ast
    ~~~

    The `ast` module helps Python applications to process trees of the Python
    abstract syntax grammar.  The abstract syntax itself might change with
    each Python release; this module helps to find out programmatically what
    the current grammar looks like and allows modifications of it.

    An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
    a flag to the `compile()` builtin function or by using the `parse()`
    function kutoka this module.  The result will be a tree of objects whose
    classes all inherit kutoka `ast.AST`.

    A modified abstract syntax tree can be compiled into a Python code object
    using the built-in `compile()` function.

    Additionally various helper functions are provided that make working with
    the trees simpler.  The main intention of the helper functions and this
    module in general is to provide an easy to use interface for libraries
    that work tightly with the python syntax (template engines for example).


    :copyright: Copyright 2008 by Armin Ronacher.
    :license: Python License.
"""
kutoka _ast agiza *


eleza parse(source, filename='<unknown>', mode='exec', *,
          type_comments=False, feature_version=None):
    """
    Parse the source into an AST node.
    Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
    Pass type_comments=True to get back type comments where the syntax allows.
    """
    flags = PyCF_ONLY_AST
    ikiwa type_comments:
        flags |= PyCF_TYPE_COMMENTS
    ikiwa isinstance(feature_version, tuple):
        major, minor = feature_version  # Should be a 2-tuple.
        assert major == 3
        feature_version = minor
    elikiwa feature_version is None:
        feature_version = -1
    # Else it should be an int giving the minor version for 3.x.
    rudisha compile(source, filename, mode, flags,
                   _feature_version=feature_version)


eleza literal_eval(node_or_string):
    """
    Safely evaluate an expression node or a string containing a Python
    expression.  The string or node provided may only consist of the following
    Python literal structures: strings, bytes, numbers, tuples, lists, dicts,
    sets, booleans, and None.
    """
    ikiwa isinstance(node_or_string, str):
        node_or_string = parse(node_or_string, mode='eval')
    ikiwa isinstance(node_or_string, Expression):
        node_or_string = node_or_string.body
    eleza _convert_num(node):
        ikiwa isinstance(node, Constant):
            ikiwa type(node.value) in (int, float, complex):
                rudisha node.value
        raise ValueError('malformed node or string: ' + repr(node))
    eleza _convert_signed_num(node):
        ikiwa isinstance(node, UnaryOp) and isinstance(node.op, (UAdd, USub)):
            operand = _convert_num(node.operand)
            ikiwa isinstance(node.op, UAdd):
                rudisha + operand
            else:
                rudisha - operand
        rudisha _convert_num(node)
    eleza _convert(node):
        ikiwa isinstance(node, Constant):
            rudisha node.value
        elikiwa isinstance(node, Tuple):
            rudisha tuple(map(_convert, node.elts))
        elikiwa isinstance(node, List):
            rudisha list(map(_convert, node.elts))
        elikiwa isinstance(node, Set):
            rudisha set(map(_convert, node.elts))
        elikiwa isinstance(node, Dict):
            rudisha dict(zip(map(_convert, node.keys),
                            map(_convert, node.values)))
        elikiwa isinstance(node, BinOp) and isinstance(node.op, (Add, Sub)):
            left = _convert_signed_num(node.left)
            right = _convert_num(node.right)
            ikiwa isinstance(left, (int, float)) and isinstance(right, complex):
                ikiwa isinstance(node.op, Add):
                    rudisha left + right
                else:
                    rudisha left - right
        rudisha _convert_signed_num(node)
    rudisha _convert(node_or_string)


eleza dump(node, annotate_fields=True, include_attributes=False):
    """
    Return a formatted dump of the tree in node.  This is mainly useful for
    debugging purposes.  If annotate_fields is true (by default),
    the returned string will show the names and the values for fields.
    If annotate_fields is false, the result string will be more compact by
    omitting unambiguous field names.  Attributes such as line
    numbers and column offsets are not dumped by default.  If this is wanted,
    include_attributes can be set to true.
    """
    eleza _format(node):
        ikiwa isinstance(node, AST):
            args = []
            keywords = annotate_fields
            for field in node._fields:
                try:
                    value = getattr(node, field)
                except AttributeError:
                    keywords = True
                else:
                    ikiwa keywords:
                        args.append('%s=%s' % (field, _format(value)))
                    else:
                        args.append(_format(value))
            ikiwa include_attributes and node._attributes:
                for a in node._attributes:
                    try:
                        args.append('%s=%s' % (a, _format(getattr(node, a))))
                    except AttributeError:
                        pass
            rudisha '%s(%s)' % (node.__class__.__name__, ', '.join(args))
        elikiwa isinstance(node, list):
            rudisha '[%s]' % ', '.join(_format(x) for x in node)
        rudisha repr(node)
    ikiwa not isinstance(node, AST):
        raise TypeError('expected AST, got %r' % node.__class__.__name__)
    rudisha _format(node)


eleza copy_location(new_node, old_node):
    """
    Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`
    attributes) kutoka *old_node* to *new_node* ikiwa possible, and rudisha *new_node*.
    """
    for attr in 'lineno', 'col_offset', 'end_lineno', 'end_col_offset':
        ikiwa attr in old_node._attributes and attr in new_node._attributes \
           and hasattr(old_node, attr):
            setattr(new_node, attr, getattr(old_node, attr))
    rudisha new_node


eleza fix_missing_locations(node):
    """
    When you compile a node tree with compile(), the compiler expects lineno and
    col_offset attributes for every node that supports them.  This is rather
    tedious to fill in for generated nodes, so this helper adds these attributes
    recursively where not already set, by setting them to the values of the
    parent node.  It works recursively starting at *node*.
    """
    eleza _fix(node, lineno, col_offset, end_lineno, end_col_offset):
        ikiwa 'lineno' in node._attributes:
            ikiwa not hasattr(node, 'lineno'):
                node.lineno = lineno
            else:
                lineno = node.lineno
        ikiwa 'end_lineno' in node._attributes:
            ikiwa not hasattr(node, 'end_lineno'):
                node.end_lineno = end_lineno
            else:
                end_lineno = node.end_lineno
        ikiwa 'col_offset' in node._attributes:
            ikiwa not hasattr(node, 'col_offset'):
                node.col_offset = col_offset
            else:
                col_offset = node.col_offset
        ikiwa 'end_col_offset' in node._attributes:
            ikiwa not hasattr(node, 'end_col_offset'):
                node.end_col_offset = end_col_offset
            else:
                end_col_offset = node.end_col_offset
        for child in iter_child_nodes(node):
            _fix(child, lineno, col_offset, end_lineno, end_col_offset)
    _fix(node, 1, 0, 1, 0)
    rudisha node


eleza increment_lineno(node, n=1):
    """
    Increment the line number and end line number of each node in the tree
    starting at *node* by *n*. This is useful to "move code" to a different
    location in a file.
    """
    for child in walk(node):
        ikiwa 'lineno' in child._attributes:
            child.lineno = getattr(child, 'lineno', 0) + n
        ikiwa 'end_lineno' in child._attributes:
            child.end_lineno = getattr(child, 'end_lineno', 0) + n
    rudisha node


eleza iter_fields(node):
    """
    Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
    that is present on *node*.
    """
    for field in node._fields:
        try:
            yield field, getattr(node, field)
        except AttributeError:
            pass


eleza iter_child_nodes(node):
    """
    Yield all direct child nodes of *node*, that is, all fields that are nodes
    and all items of fields that are lists of nodes.
    """
    for name, field in iter_fields(node):
        ikiwa isinstance(field, AST):
            yield field
        elikiwa isinstance(field, list):
            for item in field:
                ikiwa isinstance(item, AST):
                    yield item


eleza get_docstring(node, clean=True):
    """
    Return the docstring for the given node or None ikiwa no docstring can
    be found.  If the node provided does not have docstrings a TypeError
    will be raised.

    If *clean* is `True`, all tabs are expanded to spaces and any whitespace
    that can be uniformly removed kutoka the second line onwards is removed.
    """
    ikiwa not isinstance(node, (AsyncFunctionDef, FunctionDef, ClassDef, Module)):
        raise TypeError("%r can't have docstrings" % node.__class__.__name__)
    ikiwa not(node.body and isinstance(node.body[0], Expr)):
        rudisha None
    node = node.body[0].value
    ikiwa isinstance(node, Str):
        text = node.s
    elikiwa isinstance(node, Constant) and isinstance(node.value, str):
        text = node.value
    else:
        rudisha None
    ikiwa clean:
        agiza inspect
        text = inspect.cleandoc(text)
    rudisha text


eleza _splitlines_no_ff(source):
    """Split a string into lines ignoring form feed and other chars.

    This mimics how the Python parser splits source code.
    """
    idx = 0
    lines = []
    next_line = ''
    while idx < len(source):
        c = source[idx]
        next_line += c
        idx += 1
        # Keep \r\n together
        ikiwa c == '\r' and idx < len(source) and source[idx] == '\n':
            next_line += '\n'
            idx += 1
        ikiwa c in '\r\n':
            lines.append(next_line)
            next_line = ''

    ikiwa next_line:
        lines.append(next_line)
    rudisha lines


eleza _pad_whitespace(source):
    """Replace all chars except '\f\t' in a line with spaces."""
    result = ''
    for c in source:
        ikiwa c in '\f\t':
            result += c
        else:
            result += ' '
    rudisha result


eleza get_source_segment(source, node, *, padded=False):
    """Get source code segment of the *source* that generated *node*.

    If some location information (`lineno`, `end_lineno`, `col_offset`,
    or `end_col_offset`) is missing, rudisha None.

    If *padded* is `True`, the first line of a multi-line statement will
    be padded with spaces to match its original position.
    """
    try:
        lineno = node.lineno - 1
        end_lineno = node.end_lineno - 1
        col_offset = node.col_offset
        end_col_offset = node.end_col_offset
    except AttributeError:
        rudisha None

    lines = _splitlines_no_ff(source)
    ikiwa end_lineno == lineno:
        rudisha lines[lineno].encode()[col_offset:end_col_offset].decode()

    ikiwa padded:
        padding = _pad_whitespace(lines[lineno].encode()[:col_offset].decode())
    else:
        padding = ''

    first = padding + lines[lineno].encode()[col_offset:].decode()
    last = lines[end_lineno].encode()[:end_col_offset].decode()
    lines = lines[lineno+1:end_lineno]

    lines.insert(0, first)
    lines.append(last)
    rudisha ''.join(lines)


eleza walk(node):
    """
    Recursively yield all descendant nodes in the tree starting at *node*
    (including *node* itself), in no specified order.  This is useful ikiwa you
    only want to modify nodes in place and don't care about the context.
    """
    kutoka collections agiza deque
    todo = deque([node])
    while todo:
        node = todo.popleft()
        todo.extend(iter_child_nodes(node))
        yield node


kundi NodeVisitor(object):
    """
    A node visitor base kundi that walks the abstract syntax tree and calls a
    visitor function for every node found.  This function may rudisha a value
    which is forwarded by the `visit` method.

    This kundi is meant to be subclassed, with the subkundi adding visitor
    methods.

    Per default the visitor functions for the nodes are ``'visit_'`` +
    kundi name of the node.  So a `TryFinally` node visit function would
    be `visit_TryFinally`.  This behavior can be changed by overriding
    the `visit` method.  If no visitor function exists for a node
    (rudisha value `None`) the `generic_visit` visitor is used instead.

    Don't use the `NodeVisitor` ikiwa you want to apply changes to nodes during
    traversing.  For this a special visitor exists (`NodeTransformer`) that
    allows modifications.
    """

    eleza visit(self, node):
        """Visit a node."""
        method = 'visit_' + node.__class__.__name__
        visitor = getattr(self, method, self.generic_visit)
        rudisha visitor(node)

    eleza generic_visit(self, node):
        """Called ikiwa no explicit visitor function exists for a node."""
        for field, value in iter_fields(node):
            ikiwa isinstance(value, list):
                for item in value:
                    ikiwa isinstance(item, AST):
                        self.visit(item)
            elikiwa isinstance(value, AST):
                self.visit(value)

    eleza visit_Constant(self, node):
        value = node.value
        type_name = _const_node_type_names.get(type(value))
        ikiwa type_name is None:
            for cls, name in _const_node_type_names.items():
                ikiwa isinstance(value, cls):
                    type_name = name
                    break
        ikiwa type_name is not None:
            method = 'visit_' + type_name
            try:
                visitor = getattr(self, method)
            except AttributeError:
                pass
            else:
                agiza warnings
                warnings.warn(f"{method} is deprecated; add visit_Constant",
                              PendingDeprecationWarning, 2)
                rudisha visitor(node)
        rudisha self.generic_visit(node)


kundi NodeTransformer(NodeVisitor):
    """
    A :class:`NodeVisitor` subkundi that walks the abstract syntax tree and
    allows modification of nodes.

    The `NodeTransformer` will walk the AST and use the rudisha value of the
    visitor methods to replace or remove the old node.  If the rudisha value of
    the visitor method is ``None``, the node will be removed kutoka its location,
    otherwise it is replaced with the rudisha value.  The rudisha value may be the
    original node in which case no replacement takes place.

    Here is an example transformer that rewrites all occurrences of name lookups
    (``foo``) to ``data['foo']``::

       kundi RewriteName(NodeTransformer):

           eleza visit_Name(self, node):
               rudisha copy_location(Subscript(
                   value=Name(id='data', ctx=Load()),
                   slice=Index(value=Str(s=node.id)),
                   ctx=node.ctx
               ), node)

    Keep in mind that ikiwa the node you're operating on has child nodes you must
    either transform the child nodes yourself or call the :meth:`generic_visit`
    method for the node first.

    For nodes that were part of a collection of statements (that applies to all
    statement nodes), the visitor may also rudisha a list of nodes rather than
    just a single node.

    Usually you use the transformer like this::

       node = YourTransformer().visit(node)
    """

    eleza generic_visit(self, node):
        for field, old_value in iter_fields(node):
            ikiwa isinstance(old_value, list):
                new_values = []
                for value in old_value:
                    ikiwa isinstance(value, AST):
                        value = self.visit(value)
                        ikiwa value is None:
                            continue
                        elikiwa not isinstance(value, AST):
                            new_values.extend(value)
                            continue
                    new_values.append(value)
                old_value[:] = new_values
            elikiwa isinstance(old_value, AST):
                new_node = self.visit(old_value)
                ikiwa new_node is None:
                    delattr(node, field)
                else:
                    setattr(node, field, new_node)
        rudisha node


# The following code is for backward compatibility.
# It will be removed in future.

eleza _getter(self):
    rudisha self.value

eleza _setter(self, value):
    self.value = value

Constant.n = property(_getter, _setter)
Constant.s = property(_getter, _setter)

kundi _ABC(type):

    eleza __instancecheck__(cls, inst):
        ikiwa not isinstance(inst, Constant):
            rudisha False
        ikiwa cls in _const_types:
            try:
                value = inst.value
            except AttributeError:
                rudisha False
            else:
                rudisha (
                    isinstance(value, _const_types[cls]) and
                    not isinstance(value, _const_types_not.get(cls, ()))
                )
        rudisha type.__instancecheck__(cls, inst)

eleza _new(cls, *args, **kwargs):
    ikiwa cls in _const_types:
        rudisha Constant(*args, **kwargs)
    rudisha Constant.__new__(cls, *args, **kwargs)

kundi Num(Constant, metaclass=_ABC):
    _fields = ('n',)
    __new__ = _new

kundi Str(Constant, metaclass=_ABC):
    _fields = ('s',)
    __new__ = _new

kundi Bytes(Constant, metaclass=_ABC):
    _fields = ('s',)
    __new__ = _new

kundi NameConstant(Constant, metaclass=_ABC):
    __new__ = _new

kundi Ellipsis(Constant, metaclass=_ABC):
    _fields = ()

    eleza __new__(cls, *args, **kwargs):
        ikiwa cls is Ellipsis:
            rudisha Constant(..., *args, **kwargs)
        rudisha Constant.__new__(cls, *args, **kwargs)

_const_types = {
    Num: (int, float, complex),
    Str: (str,),
    Bytes: (bytes,),
    NameConstant: (type(None), bool),
    Ellipsis: (type(...),),
}
_const_types_not = {
    Num: (bool,),
}
_const_node_type_names = {
    bool: 'NameConstant',  # should be before int
    type(None): 'NameConstant',
    int: 'Num',
    float: 'Num',
    complex: 'Num',
    str: 'Str',
    bytes: 'Bytes',
    type(...): 'Ellipsis',
}
