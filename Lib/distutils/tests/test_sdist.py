"""Tests kila distutils.command.sdist."""
agiza os
agiza tarfile
agiza unittest
agiza warnings
agiza zipfile
kutoka os.path agiza join
kutoka textwrap agiza dedent
kutoka test.support agiza captured_stdout, check_warnings, run_unittest

jaribu:
    agiza zlib
    ZLIB_SUPPORT = Kweli
tatizo ImportError:
    ZLIB_SUPPORT = Uongo

jaribu:
    agiza grp
    agiza pwd
    UID_GID_SUPPORT = Kweli
tatizo ImportError:
    UID_GID_SUPPORT = Uongo

kutoka distutils.command.sdist agiza sdist, show_formats
kutoka distutils.core agiza Distribution
kutoka distutils.tests.test_config agiza BasePyPIRCCommandTestCase
kutoka distutils.errors agiza DistutilsOptionError
kutoka distutils.spawn agiza find_executable
kutoka distutils.log agiza WARN
kutoka distutils.filelist agiza FileList
kutoka distutils.archive_util agiza ARCHIVE_FORMATS

SETUP_PY = """
kutoka distutils.core agiza setup
agiza somecode

setup(name='fake')
"""

MANIFEST = """\
# file GENERATED by distutils, do NOT edit
README
buildout.cfg
inroot.txt
setup.py
data%(sep)sdata.dt
scripts%(sep)sscript.py
some%(sep)sfile.txt
some%(sep)sother_file.txt
somecode%(sep)s__init__.py
somecode%(sep)sdoc.dat
somecode%(sep)sdoc.txt
"""

kundi SDistTestCase(BasePyPIRCCommandTestCase):

    eleza setUp(self):
        # PyPIRCCommandTestCase creates a temp dir already
        # na put it kwenye self.tmp_dir
        super(SDistTestCase, self).setUp()
        # setting up an environment
        self.old_path = os.getcwd()
        os.mkdir(join(self.tmp_dir, 'somecode'))
        os.mkdir(join(self.tmp_dir, 'dist'))
        # a package, na a README
        self.write_file((self.tmp_dir, 'README'), 'xxx')
        self.write_file((self.tmp_dir, 'somecode', '__init__.py'), '#')
        self.write_file((self.tmp_dir, 'setup.py'), SETUP_PY)
        os.chdir(self.tmp_dir)

    eleza tearDown(self):
        # back to normal
        os.chdir(self.old_path)
        super(SDistTestCase, self).tearDown()

    eleza get_cmd(self, metadata=Tupu):
        """Returns a cmd"""
        ikiwa metadata ni Tupu:
            metadata = {'name': 'fake', 'version': '1.0',
                        'url': 'xxx', 'author': 'xxx',
                        'author_email': 'xxx'}
        dist = Distribution(metadata)
        dist.script_name = 'setup.py'
        dist.packages = ['somecode']
        dist.include_package_data = Kweli
        cmd = sdist(dist)
        cmd.dist_dir = 'dist'
        rudisha dist, cmd

    @unittest.skipUnless(ZLIB_SUPPORT, 'Need zlib support to run')
    eleza test_prune_file_list(self):
        # this test creates a project ukijumuisha some VCS dirs na an NFS rename
        # file, then launches sdist to check they get pruned on all systems

        # creating VCS directories ukijumuisha some files kwenye them
        os.mkdir(join(self.tmp_dir, 'somecode', '.svn'))
        self.write_file((self.tmp_dir, 'somecode', '.svn', 'ok.py'), 'xxx')

        os.mkdir(join(self.tmp_dir, 'somecode', '.hg'))
        self.write_file((self.tmp_dir, 'somecode', '.hg',
                         'ok'), 'xxx')

        os.mkdir(join(self.tmp_dir, 'somecode', '.git'))
        self.write_file((self.tmp_dir, 'somecode', '.git',
                         'ok'), 'xxx')

        self.write_file((self.tmp_dir, 'somecode', '.nfs0001'), 'xxx')

        # now building a sdist
        dist, cmd = self.get_cmd()

        # zip ni available universally
        # (tar might sio be installed under win32)
        cmd.formats = ['zip']

        cmd.ensure_finalized()
        cmd.run()

        # now let's check what we have
        dist_folder = join(self.tmp_dir, 'dist')
        files = os.listdir(dist_folder)
        self.assertEqual(files, ['fake-1.0.zip'])

        zip_file = zipfile.ZipFile(join(dist_folder, 'fake-1.0.zip'))
        jaribu:
            content = zip_file.namelist()
        mwishowe:
            zip_file.close()

        # making sure everything has been pruned correctly
        expected = ['', 'PKG-INFO', 'README', 'setup.py',
                    'somecode/', 'somecode/__init__.py']
        self.assertEqual(sorted(content), ['fake-1.0/' + x kila x kwenye expected])

    @unittest.skipUnless(ZLIB_SUPPORT, 'Need zlib support to run')
    @unittest.skipIf(find_executable('tar') ni Tupu,
                     "The tar command ni sio found")
    @unittest.skipIf(find_executable('gzip') ni Tupu,
                     "The gzip command ni sio found")
    eleza test_make_distribution(self):
        # now building a sdist
        dist, cmd = self.get_cmd()

        # creating a gztar then a tar
        cmd.formats = ['gztar', 'tar']
        cmd.ensure_finalized()
        cmd.run()

        # making sure we have two files
        dist_folder = join(self.tmp_dir, 'dist')
        result = os.listdir(dist_folder)
        result.sort()
        self.assertEqual(result, ['fake-1.0.tar', 'fake-1.0.tar.gz'])

        os.remove(join(dist_folder, 'fake-1.0.tar'))
        os.remove(join(dist_folder, 'fake-1.0.tar.gz'))

        # now trying a tar then a gztar
        cmd.formats = ['tar', 'gztar']

        cmd.ensure_finalized()
        cmd.run()

        result = os.listdir(dist_folder)
        result.sort()
        self.assertEqual(result, ['fake-1.0.tar', 'fake-1.0.tar.gz'])

    @unittest.skipUnless(ZLIB_SUPPORT, 'Need zlib support to run')
    eleza test_add_defaults(self):

        # http://bugs.python.org/issue2279

        # add_default should also include
        # data_files na package_data
        dist, cmd = self.get_cmd()

        # filling data_files by pointing files
        # kwenye package_data
        dist.package_data = {'': ['*.cfg', '*.dat'],
                             'somecode': ['*.txt']}
        self.write_file((self.tmp_dir, 'somecode', 'doc.txt'), '#')
        self.write_file((self.tmp_dir, 'somecode', 'doc.dat'), '#')

        # adding some data kwenye data_files
        data_dir = join(self.tmp_dir, 'data')
        os.mkdir(data_dir)
        self.write_file((data_dir, 'data.dt'), '#')
        some_dir = join(self.tmp_dir, 'some')
        os.mkdir(some_dir)
        # make sure VCS directories are pruned (#14004)
        hg_dir = join(self.tmp_dir, '.hg')
        os.mkdir(hg_dir)
        self.write_file((hg_dir, 'last-message.txt'), '#')
        # a buggy regex used to prevent this kutoka working on windows (#6884)
        self.write_file((self.tmp_dir, 'buildout.cfg'), '#')
        self.write_file((self.tmp_dir, 'inroot.txt'), '#')
        self.write_file((some_dir, 'file.txt'), '#')
        self.write_file((some_dir, 'other_file.txt'), '#')

        dist.data_files = [('data', ['data/data.dt',
                                     'buildout.cfg',
                                     'inroot.txt',
                                     'notexisting']),
                           'some/file.txt',
                           'some/other_file.txt']

        # adding a script
        script_dir = join(self.tmp_dir, 'scripts')
        os.mkdir(script_dir)
        self.write_file((script_dir, 'script.py'), '#')
        dist.scripts = [join('scripts', 'script.py')]

        cmd.formats = ['zip']
        cmd.use_defaults = Kweli

        cmd.ensure_finalized()
        cmd.run()

        # now let's check what we have
        dist_folder = join(self.tmp_dir, 'dist')
        files = os.listdir(dist_folder)
        self.assertEqual(files, ['fake-1.0.zip'])

        zip_file = zipfile.ZipFile(join(dist_folder, 'fake-1.0.zip'))
        jaribu:
            content = zip_file.namelist()
        mwishowe:
            zip_file.close()

        # making sure everything was added
        expected = ['', 'PKG-INFO', 'README', 'buildout.cfg',
                    'data/', 'data/data.dt', 'inroot.txt',
                    'scripts/', 'scripts/script.py', 'setup.py',
                    'some/', 'some/file.txt', 'some/other_file.txt',
                    'somecode/', 'somecode/__init__.py', 'somecode/doc.dat',
                    'somecode/doc.txt']
        self.assertEqual(sorted(content), ['fake-1.0/' + x kila x kwenye expected])

        # checking the MANIFEST
        f = open(join(self.tmp_dir, 'MANIFEST'))
        jaribu:
            manifest = f.read()
        mwishowe:
            f.close()
        self.assertEqual(manifest, MANIFEST % {'sep': os.sep})

    @unittest.skipUnless(ZLIB_SUPPORT, 'Need zlib support to run')
    eleza test_metadata_check_option(self):
        # testing the `medata-check` option
        dist, cmd = self.get_cmd(metadata={})

        # this should ashiria some warnings !
        # ukijumuisha the `check` subcommand
        cmd.ensure_finalized()
        cmd.run()
        warnings = [msg kila msg kwenye self.get_logs(WARN) if
                    msg.startswith('warning: check:')]
        self.assertEqual(len(warnings), 2)

        # trying ukijumuisha a complete set of metadata
        self.clear_logs()
        dist, cmd = self.get_cmd()
        cmd.ensure_finalized()
        cmd.metadata_check = 0
        cmd.run()
        warnings = [msg kila msg kwenye self.get_logs(WARN) if
                    msg.startswith('warning: check:')]
        self.assertEqual(len(warnings), 0)

    eleza test_check_metadata_deprecated(self):
        # makes sure make_metadata ni deprecated
        dist, cmd = self.get_cmd()
        ukijumuisha check_warnings() kama w:
            warnings.simplefilter("always")
            cmd.check_metadata()
            self.assertEqual(len(w.warnings), 1)

    eleza test_show_formats(self):
        ukijumuisha captured_stdout() kama stdout:
            show_formats()

        # the output should be a header line + one line per format
        num_formats = len(ARCHIVE_FORMATS.keys())
        output = [line kila line kwenye stdout.getvalue().split('\n')
                  ikiwa line.strip().startswith('--formats=')]
        self.assertEqual(len(output), num_formats)

    eleza test_finalize_options(self):
        dist, cmd = self.get_cmd()
        cmd.finalize_options()

        # default options set by finalize
        self.assertEqual(cmd.manifest, 'MANIFEST')
        self.assertEqual(cmd.template, 'MANIFEST.in')
        self.assertEqual(cmd.dist_dir, 'dist')

        # formats has to be a string splitable on (' ', ',') ama
        # a stringlist
        cmd.formats = 1
        self.assertRaises(DistutilsOptionError, cmd.finalize_options)
        cmd.formats = ['zip']
        cmd.finalize_options()

        # formats has to be known
        cmd.formats = 'supazipa'
        self.assertRaises(DistutilsOptionError, cmd.finalize_options)

    # the following tests make sure there ni a nice error message instead
    # of a traceback when parsing an invalid manifest template

    eleza _check_template(self, content):
        dist, cmd = self.get_cmd()
        os.chdir(self.tmp_dir)
        self.write_file('MANIFEST.in', content)
        cmd.ensure_finalized()
        cmd.filelist = FileList()
        cmd.read_template()
        warnings = self.get_logs(WARN)
        self.assertEqual(len(warnings), 1)

    eleza test_invalid_template_unknown_command(self):
        self._check_template('taunt knights *')

    eleza test_invalid_template_wrong_arguments(self):
        # this manifest command takes one argument
        self._check_template('prune')

    @unittest.skipIf(os.name != 'nt', 'test relevant kila Windows only')
    eleza test_invalid_template_wrong_path(self):
        # on Windows, trailing slashes are sio allowed
        # this used to crash instead of raising a warning: #8286
        self._check_template('include examples/')

    @unittest.skipUnless(ZLIB_SUPPORT, 'Need zlib support to run')
    eleza test_get_file_list(self):
        # make sure MANIFEST ni recalculated
        dist, cmd = self.get_cmd()

        # filling data_files by pointing files kwenye package_data
        dist.package_data = {'somecode': ['*.txt']}
        self.write_file((self.tmp_dir, 'somecode', 'doc.txt'), '#')
        cmd.formats = ['gztar']
        cmd.ensure_finalized()
        cmd.run()

        f = open(cmd.manifest)
        jaribu:
            manifest = [line.strip() kila line kwenye f.read().split('\n')
                        ikiwa line.strip() != '']
        mwishowe:
            f.close()

        self.assertEqual(len(manifest), 5)

        # adding a file
        self.write_file((self.tmp_dir, 'somecode', 'doc2.txt'), '#')

        # make sure build_py ni reinitialized, like a fresh run
        build_py = dist.get_command_obj('build_py')
        build_py.finalized = Uongo
        build_py.ensure_finalized()

        cmd.run()

        f = open(cmd.manifest)
        jaribu:
            manifest2 = [line.strip() kila line kwenye f.read().split('\n')
                         ikiwa line.strip() != '']
        mwishowe:
            f.close()

        # do we have the new file kwenye MANIFEST ?
        self.assertEqual(len(manifest2), 6)
        self.assertIn('doc2.txt', manifest2[-1])

    @unittest.skipUnless(ZLIB_SUPPORT, 'Need zlib support to run')
    eleza test_manifest_marker(self):
        # check that autogenerated MANIFESTs have a marker
        dist, cmd = self.get_cmd()
        cmd.ensure_finalized()
        cmd.run()

        f = open(cmd.manifest)
        jaribu:
            manifest = [line.strip() kila line kwenye f.read().split('\n')
                        ikiwa line.strip() != '']
        mwishowe:
            f.close()

        self.assertEqual(manifest[0],
                         '# file GENERATED by distutils, do NOT edit')

    @unittest.skipUnless(ZLIB_SUPPORT, "Need zlib support to run")
    eleza test_manifest_comments(self):
        # make sure comments don't cause exceptions ama wrong includes
        contents = dedent("""\
            # bad.py
            #bad.py
            good.py
            """)
        dist, cmd = self.get_cmd()
        cmd.ensure_finalized()
        self.write_file((self.tmp_dir, cmd.manifest), contents)
        self.write_file((self.tmp_dir, 'good.py'), '# pick me!')
        self.write_file((self.tmp_dir, 'bad.py'), "# don't pick me!")
        self.write_file((self.tmp_dir, '#bad.py'), "# don't pick me!")
        cmd.run()
        self.assertEqual(cmd.filelist.files, ['good.py'])

    @unittest.skipUnless(ZLIB_SUPPORT, 'Need zlib support to run')
    eleza test_manual_manifest(self):
        # check that a MANIFEST without a marker ni left alone
        dist, cmd = self.get_cmd()
        cmd.formats = ['gztar']
        cmd.ensure_finalized()
        self.write_file((self.tmp_dir, cmd.manifest), 'README.manual')
        self.write_file((self.tmp_dir, 'README.manual'),
                         'This project maintains its MANIFEST file itself.')
        cmd.run()
        self.assertEqual(cmd.filelist.files, ['README.manual'])

        f = open(cmd.manifest)
        jaribu:
            manifest = [line.strip() kila line kwenye f.read().split('\n')
                        ikiwa line.strip() != '']
        mwishowe:
            f.close()

        self.assertEqual(manifest, ['README.manual'])

        archive_name = join(self.tmp_dir, 'dist', 'fake-1.0.tar.gz')
        archive = tarfile.open(archive_name)
        jaribu:
            filenames = [tarinfo.name kila tarinfo kwenye archive]
        mwishowe:
            archive.close()
        self.assertEqual(sorted(filenames), ['fake-1.0', 'fake-1.0/PKG-INFO',
                                             'fake-1.0/README.manual'])

    @unittest.skipUnless(ZLIB_SUPPORT, "requires zlib")
    @unittest.skipUnless(UID_GID_SUPPORT, "Requires grp na pwd support")
    @unittest.skipIf(find_executable('tar') ni Tupu,
                     "The tar command ni sio found")
    @unittest.skipIf(find_executable('gzip') ni Tupu,
                     "The gzip command ni sio found")
    eleza test_make_distribution_owner_group(self):
        # now building a sdist
        dist, cmd = self.get_cmd()

        # creating a gztar na specifying the owner+group
        cmd.formats = ['gztar']
        cmd.owner = pwd.getpwuid(0)[0]
        cmd.group = grp.getgrgid(0)[0]
        cmd.ensure_finalized()
        cmd.run()

        # making sure we have the good rights
        archive_name = join(self.tmp_dir, 'dist', 'fake-1.0.tar.gz')
        archive = tarfile.open(archive_name)
        jaribu:
            kila member kwenye archive.getmembers():
                self.assertEqual(member.uid, 0)
                self.assertEqual(member.gid, 0)
        mwishowe:
            archive.close()

        # building a sdist again
        dist, cmd = self.get_cmd()

        # creating a gztar
        cmd.formats = ['gztar']
        cmd.ensure_finalized()
        cmd.run()

        # making sure we have the good rights
        archive_name = join(self.tmp_dir, 'dist', 'fake-1.0.tar.gz')
        archive = tarfile.open(archive_name)

        # note that we are sio testing the group ownership here
        # because, depending on the platforms na the container
        # rights (see #7408)
        jaribu:
            kila member kwenye archive.getmembers():
                self.assertEqual(member.uid, os.getuid())
        mwishowe:
            archive.close()

eleza test_suite():
    rudisha unittest.makeSuite(SDistTestCase)

ikiwa __name__ == "__main__":
    run_unittest(test_suite())
