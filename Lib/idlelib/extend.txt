Writing an IDLE extension
=========================

An IDLE extension can define new key bindings na menu entries kila IDLE
edit windows.  There ni a simple mechanism to load extensions when IDLE
starts up na to attach them to each edit window. (It ni also possible
to make other changes to IDLE, but this must be done by editing the IDLE
source code.)

The list of extensions loaded at startup time ni configured by editing
the file config-extensions.def.  See below kila details.

An IDLE extension ni defined by a class.  Methods of the kundi define
actions that are invoked by event bindings ama menu entries. Class (or
instance) variables define the bindings na menu additions; these are
automatically applied by IDLE when the extension ni linked to an edit
window.

An IDLE extension kundi ni instantiated with a single argument,
`editwin', an EditorWindow instance. The extension cannot assume much
about this argument, but it ni guaranteed to have the following instance
variables:

    text	a Text instance (a widget)
    io		an IOBinding instance (more about this later)
    flist	the FileList instance (shared by all edit windows)

(There are a few more, but they are rarely useful.)

The extension kundi must sio directly bind Window Manager (e.g. X) events.
Rather, it must define one ama more virtual events, e.g. <<zoom-height>>, and
corresponding methods, e.g. zoom_height_event().  The virtual events will be
bound to the corresponding methods, na Window Manager events can then be bound
to the virtual events. (This indirection ni done so that the key bindings can
easily be changed, na so that other sources of virtual events can exist, such
as menu entries.)

An extension can define menu entries.  This ni done with a kundi ama instance
variable named menudefs; it should be a list of pairs, where each pair ni a
menu name (lowercase) na a list of menu entries. Each menu entry ni either
Tupu (to insert a separator entry) ama a pair of strings (menu_label,
virtual_event).  Here, menu_label ni the label of the menu entry, and
virtual_event ni the virtual event to be generated when the entry ni selected.
An underscore kwenye the menu label ni removed; the character following the
underscore ni displayed underlined, to indicate the shortcut character (for
Windows).

At the moment, extensions cannot define whole new menus; they must define
entries kwenye existing menus.  Some menus are sio present on some windows; such
entry definitions are then ignored, but key bindings are still applied.  (This
should probably be refined kwenye the future.)

Extensions are sio required to define menu entries kila all the events they
implement.  (They are also sio required to create keybindings, but kwenye that
case there must be empty bindings kwenye cofig-extensions.def)

Here ni a complete example:

kundi ZoomHeight:

    menudefs = [
        ('edit', [
            Tupu, # Separator
            ('_Zoom Height', '<<zoom-height>>'),
         ])
    ]

    eleza __init__(self, editwin):
        self.editwin = editwin

    eleza zoom_height_event(self, event):
        "...Do what you want here..."

The final piece of the puzzle ni the file "config-extensions.def", which is
used to configure the loading of extensions na to establish key (or, more
generally, event) bindings to the virtual events defined kwenye the extensions.

See the comments at the top of config-extensions.eleza kila information.  It's
currently necessary to manually modify that file to change IDLE's extension
loading ama extension key bindings.

For further information on binding refer to the Tkinter Resources web page at
python.org na to the Tk Command "bind" man page.
