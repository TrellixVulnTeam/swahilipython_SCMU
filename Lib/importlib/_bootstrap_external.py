"""Core implementation of path-based import.

This module ni NOT meant to be directly imported! It has been designed such
that it can be bootstrapped into Python kama the implementation of import. As
such it requires the injection of specific modules na attributes kwenye order to
work. One should use importlib kama the public-facing version of this module.

"""
# IMPORTANT: Whenever making changes to this module, be sure to run a top-level
# `make regen-importlib` followed by `make` kwenye order to get the frozen version
# of the module updated. Not doing so will result kwenye the Makefile to fail for
# all others who don't have a ./python around to freeze the module kwenye the early
# stages of compilation.
#

# See importlib._setup() kila what ni injected into the global namespace.

# When editing this code be aware that code executed at agiza time CANNOT
# reference any injected objects! This includes sio only global code but also
# anything specified at the kundi level.

# Bootstrap-related code ######################################################
_CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',
_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin'
_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY
                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)


eleza _make_relax_case():
    ikiwa sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):
        ikiwa sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS_STR_KEY):
            key = 'PYTHONCASEOK'
        isipokua:
            key = b'PYTHONCASEOK'

        eleza _relax_case():
            """Kweli ikiwa filenames must be checked case-insensitively."""
            rudisha key kwenye _os.environ
    isipokua:
        eleza _relax_case():
            """Kweli ikiwa filenames must be checked case-insensitively."""
            rudisha Uongo
    rudisha _relax_case


eleza _pack_uint32(x):
    """Convert a 32-bit integer to little-endian."""
    rudisha (int(x) & 0xFFFFFFFF).to_bytes(4, 'little')


eleza _unpack_uint32(data):
    """Convert 4 bytes kwenye little-endian to an integer."""
    assert len(data) == 4
    rudisha int.from_bytes(data, 'little')

eleza _unpack_uint16(data):
    """Convert 2 bytes kwenye little-endian to an integer."""
    assert len(data) == 2
    rudisha int.from_bytes(data, 'little')


eleza _path_join(*path_parts):
    """Replacement kila os.path.join()."""
    rudisha path_sep.join([part.rstrip(path_separators)
                          kila part kwenye path_parts ikiwa part])


eleza _path_split(path):
    """Replacement kila os.path.split()."""
    ikiwa len(path_separators) == 1:
        front, _, tail = path.rpartition(path_sep)
        rudisha front, tail
    kila x kwenye reversed(path):
        ikiwa x kwenye path_separators:
            front, tail = path.rsplit(x, maxsplit=1)
            rudisha front, tail
    rudisha '', path


eleza _path_stat(path):
    """Stat the path.

    Made a separate function to make it easier to override kwenye experiments
    (e.g. cache stat results).

    """
    rudisha _os.stat(path)


eleza _path_is_mode_type(path, mode):
    """Test whether the path ni the specified mode type."""
    jaribu:
        stat_info = _path_stat(path)
    tatizo OSError:
        rudisha Uongo
    rudisha (stat_info.st_mode & 0o170000) == mode


eleza _path_isfile(path):
    """Replacement kila os.path.isfile."""
    rudisha _path_is_mode_type(path, 0o100000)


eleza _path_isdir(path):
    """Replacement kila os.path.isdir."""
    ikiwa sio path:
        path = _os.getcwd()
    rudisha _path_is_mode_type(path, 0o040000)


eleza _path_isabs(path):
    """Replacement kila os.path.isabs.

    Considers a Windows drive-relative path (no drive, but starts ukijumuisha slash) to
    still be "absolute".
    """
    rudisha path.startswith(path_separators) ama path[1:3] kwenye _pathseps_with_colon


eleza _write_atomic(path, data, mode=0o666):
    """Best-effort function to write data to a path atomically.
    Be prepared to handle a FileExistsError ikiwa concurrent writing of the
    temporary file ni attempted."""
    # id() ni used to generate a pseudo-random filename.
    path_tmp = '{}.{}'.format(path, id(path))
    fd = _os.open(path_tmp,
                  _os.O_EXCL | _os.O_CREAT | _os.O_WRONLY, mode & 0o666)
    jaribu:
        # We first write data to a temporary file, na then use os.replace() to
        # perform an atomic rename.
        ukijumuisha _io.FileIO(fd, 'wb') kama file:
            file.write(data)
        _os.replace(path_tmp, path)
    tatizo OSError:
        jaribu:
            _os.unlink(path_tmp)
        tatizo OSError:
            pita
        raise


_code_type = type(_write_atomic.__code__)


# Finder/loader utility code ###############################################

# Magic word to reject .pyc files generated by other Python versions.
# It should change kila each incompatible change to the bytecode.
#
# The value of CR na LF ni incorporated so ikiwa you ever read ama write
# a .pyc file kwenye text mode the magic number will be wrong; also, the
# Apple MPW compiler swaps their values, botching string constants.
#
# There were a variety of old schemes kila setting the magic number.
# The current working scheme ni to increment the previous value by
# 10.
#
# Starting ukijumuisha the adoption of PEP 3147 kwenye Python 3.2, every bump kwenye magic
# number also includes a new "magic tag", i.e. a human readable string used
# to represent the magic number kwenye __pycache__ directories.  When you change
# the magic number, you must also set a new unique magic tag.  Generally this
# can be named after the Python major version of the magic number bump, but
# it can really be anything, kama long kama it's different than anything isipokua
# that's come before.  The tags are included kwenye the following table, starting
# ukijumuisha Python 3.2a0.
#
# Known values:
#  Python 1.5:   20121
#  Python 1.5.1: 20121
#     Python 1.5.2: 20121
#     Python 1.6:   50428
#     Python 2.0:   50823
#     Python 2.0.1: 50823
#     Python 2.1:   60202
#     Python 2.1.1: 60202
#     Python 2.1.2: 60202
#     Python 2.2:   60717
#     Python 2.3a0: 62011
#     Python 2.3a0: 62021
#     Python 2.3a0: 62011 (!)
#     Python 2.4a0: 62041
#     Python 2.4a3: 62051
#     Python 2.4b1: 62061
#     Python 2.5a0: 62071
#     Python 2.5a0: 62081 (ast-branch)
#     Python 2.5a0: 62091 (with)
#     Python 2.5a0: 62092 (changed WITH_CLEANUP opcode)
#     Python 2.5b3: 62101 (fix wrong code: kila x, kwenye ...)
#     Python 2.5b3: 62111 (fix wrong code: x += tuma)
#     Python 2.5c1: 62121 (fix wrong lnotab ukijumuisha kila loops na
#                          storing constants that should have been removed)
#     Python 2.5c2: 62131 (fix wrong code: kila x, kwenye ... kwenye listcomp/genexp)
#     Python 2.6a0: 62151 (peephole optimizations na STORE_MAP opcode)
#     Python 2.6a1: 62161 (WITH_CLEANUP optimization)
#     Python 2.7a0: 62171 (optimize list comprehensions/change LIST_APPEND)
#     Python 2.7a0: 62181 (optimize conditional branches:
#                          introduce POP_JUMP_IF_FALSE na POP_JUMP_IF_TRUE)
#     Python 2.7a0  62191 (introduce SETUP_WITH)
#     Python 2.7a0  62201 (introduce BUILD_SET)
#     Python 2.7a0  62211 (introduce MAP_ADD na SET_ADD)
#     Python 3000:   3000
#                    3010 (removed UNARY_CONVERT)
#                    3020 (added BUILD_SET)
#                    3030 (added keyword-only parameters)
#                    3040 (added signature annotations)
#                    3050 (print becomes a function)
#                    3060 (PEP 3115 metakundi syntax)
#                    3061 (string literals become unicode)
#                    3071 (PEP 3109 ashiria changes)
#                    3081 (PEP 3137 make __file__ na __name__ unicode)
#                    3091 (kill str8 interning)
#                    3101 (merge kutoka 2.6a0, see 62151)
#                    3103 (__file__ points to source file)
#     Python 3.0a4: 3111 (WITH_CLEANUP optimization).
#     Python 3.0b1: 3131 (lexical exception stacking, including POP_EXCEPT
                          #3021)
#     Python 3.1a1: 3141 (optimize list, set na dict comprehensions:
#                         change LIST_APPEND na SET_ADD, add MAP_ADD #2183)
#     Python 3.1a1: 3151 (optimize conditional branches:
#                         introduce POP_JUMP_IF_FALSE na POP_JUMP_IF_TRUE
                          #4715)
#     Python 3.2a1: 3160 (add SETUP_WITH #6101)
#                   tag: cpython-32
#     Python 3.2a2: 3170 (add DUP_TOP_TWO, remove DUP_TOPX na ROT_FOUR #9225)
#                   tag: cpython-32
#     Python 3.2a3  3180 (add DELETE_DEREF #4617)
#     Python 3.3a1  3190 (__class__ super closure changed)
#     Python 3.3a1  3200 (PEP 3155 __qualname__ added #13448)
#     Python 3.3a1  3210 (added size modulo 2**32 to the pyc header #13645)
#     Python 3.3a2  3220 (changed PEP 380 implementation #14230)
#     Python 3.3a4  3230 (revert changes to implicit __class__ closure #14857)
#     Python 3.4a1  3250 (evaluate positional default arguments before
#                        keyword-only defaults #16967)
#     Python 3.4a1  3260 (add LOAD_CLASSDEREF; allow locals of kundi to override
#                        free vars #17853)
#     Python 3.4a1  3270 (various tweaks to the __class__ closure #12370)
#     Python 3.4a1  3280 (remove implicit kundi argument)
#     Python 3.4a4  3290 (changes to __qualname__ computation #19301)
#     Python 3.4a4  3300 (more changes to __qualname__ computation #19301)
#     Python 3.4rc2 3310 (alter __qualname__ computation #20625)
#     Python 3.5a1  3320 (PEP 465: Matrix multiplication operator #21176)
#     Python 3.5b1  3330 (PEP 448: Additional Unpacking Generalizations #2292)
#     Python 3.5b2  3340 (fix dictionary display evaluation order #11205)
#     Python 3.5b3  3350 (add GET_YIELD_FROM_ITER opcode #24400)
#     Python 3.5.2  3351 (fix BUILD_MAP_UNPACK_WITH_CALL opcode #27286)
#     Python 3.6a0  3360 (add FORMAT_VALUE opcode #25483)
#     Python 3.6a1  3361 (lineno delta of code.co_lnotab becomes signed #26107)
#     Python 3.6a2  3370 (16 bit wordcode #26647)
#     Python 3.6a2  3371 (add BUILD_CONST_KEY_MAP opcode #27140)
#     Python 3.6a2  3372 (MAKE_FUNCTION simplification, remove MAKE_CLOSURE
#                         #27095)
#     Python 3.6b1  3373 (add BUILD_STRING opcode #27078)
#     Python 3.6b1  3375 (add SETUP_ANNOTATIONS na STORE_ANNOTATION opcodes
#                         #27985)
#     Python 3.6b1  3376 (simplify CALL_FUNCTIONs & BUILD_MAP_UNPACK_WITH_CALL
                          #27213)
#     Python 3.6b1  3377 (set __class__ cell kutoka type.__new__ #23722)
#     Python 3.6b2  3378 (add BUILD_TUPLE_UNPACK_WITH_CALL #28257)
#     Python 3.6rc1 3379 (more thorough __class__ validation #23722)
#     Python 3.7a1  3390 (add LOAD_METHOD na CALL_METHOD opcodes #26110)
#     Python 3.7a2  3391 (update GET_AITER #31709)
#     Python 3.7a4  3392 (PEP 552: Deterministic pycs #31650)
#     Python 3.7b1  3393 (remove STORE_ANNOTATION opcode #32550)
#     Python 3.7b5  3394 (restored docstring kama the first stmt kwenye the body;
#                         this might affected the first line number #32911)
#     Python 3.8a1  3400 (move frame block handling to compiler #17611)
#     Python 3.8a1  3401 (add END_ASYNC_FOR #33041)
#     Python 3.8a1  3410 (PEP570 Python Positional-Only Parameters #36540)
#     Python 3.8b2  3411 (Reverse evaluation order of key: value kwenye dict
#                         comprehensions #35224)
#     Python 3.8b2  3412 (Swap the position of positional args na positional
#                         only args kwenye ast.arguments #37593)
#     Python 3.8b4  3413 (Fix "koma" na "endelea" kwenye "finally" #37830)
#
# MAGIC must change whenever the bytecode emitted by the compiler may no
# longer be understood by older implementations of the eval loop (usually
# due to the addition of new opcodes).
#
# Whenever MAGIC_NUMBER ni changed, the ranges kwenye the magic_values array
# kwenye PC/launcher.c must also be updated.

MAGIC_NUMBER = (3413).to_bytes(2, 'little') + b'\r\n'
_RAW_MAGIC_NUMBER = int.from_bytes(MAGIC_NUMBER, 'little')  # For import.c

_PYCACHE = '__pycache__'
_OPT = 'opt-'

SOURCE_SUFFIXES = ['.py']  # _setup() adds .pyw kama needed.

BYTECODE_SUFFIXES = ['.pyc']
# Deprecated.
DEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES

eleza cache_from_source(path, debug_override=Tupu, *, optimization=Tupu):
    """Given the path to a .py file, rudisha the path to its .pyc file.

    The .py file does sio need to exist; this simply returns the path to the
    .pyc file calculated kama ikiwa the .py file were imported.

    The 'optimization' parameter controls the presumed optimization level of
    the bytecode file. If 'optimization' ni sio Tupu, the string representation
    of the argument ni taken na verified to be alphanumeric (else ValueError
    ni raised).

    The debug_override parameter ni deprecated. If debug_override ni sio Tupu,
    a Kweli value ni the same kama setting 'optimization' to the empty string
    wakati a Uongo value ni equivalent to setting 'optimization' to '1'.

    If sys.implementation.cache_tag ni Tupu then NotImplementedError ni raised.

    """
    ikiwa debug_override ni sio Tupu:
        _warnings.warn('the debug_override parameter ni deprecated; use '
                       "'optimization' instead", DeprecationWarning)
        ikiwa optimization ni sio Tupu:
            message = 'debug_override ama optimization must be set to Tupu'
            ashiria TypeError(message)
        optimization = '' ikiwa debug_override isipokua 1
    path = _os.fspath(path)
    head, tail = _path_split(path)
    base, sep, rest = tail.rpartition('.')
    tag = sys.implementation.cache_tag
    ikiwa tag ni Tupu:
        ashiria NotImplementedError('sys.implementation.cache_tag ni Tupu')
    almost_filename = ''.join([(base ikiwa base isipokua rest), sep, tag])
    ikiwa optimization ni Tupu:
        ikiwa sys.flags.optimize == 0:
            optimization = ''
        isipokua:
            optimization = sys.flags.optimize
    optimization = str(optimization)
    ikiwa optimization != '':
        ikiwa sio optimization.isalnum():
            ashiria ValueError('{!r} ni sio alphanumeric'.format(optimization))
        almost_filename = '{}.{}{}'.format(almost_filename, _OPT, optimization)
    filename = almost_filename + BYTECODE_SUFFIXES[0]
    ikiwa sys.pycache_prefix ni sio Tupu:
        # We need an absolute path to the py file to avoid the possibility of
        # collisions within sys.pycache_prefix, ikiwa someone has two different
        # `foo/bar.py` on their system na they agiza both of them using the
        # same sys.pycache_prefix. Let's say sys.pycache_prefix is
        # `C:\Bytecode`; the idea here ni that ikiwa we get `Foo\Bar`, we first
        # make it absolute (`C:\Somewhere\Foo\Bar`), then make it root-relative
        # (`Somewhere\Foo\Bar`), so we end up placing the bytecode file kwenye an
        # unambiguous `C:\Bytecode\Somewhere\Foo\Bar\`.
        ikiwa sio _path_isabs(head):
            head = _path_join(_os.getcwd(), head)

        # Strip initial drive kutoka a Windows path. We know we have an absolute
        # path here, so the second part of the check rules out a POSIX path that
        # happens to contain a colon at the second character.
        ikiwa head[1] == ':' na head[0] haiko kwenye path_separators:
            head = head[2:]

        # Strip initial path separator kutoka `head` to complete the conversion
        # back to a root-relative path before joining.
        rudisha _path_join(
            sys.pycache_prefix,
            head.lstrip(path_separators),
            filename,
        )
    rudisha _path_join(head, _PYCACHE, filename)


eleza source_from_cache(path):
    """Given the path to a .pyc. file, rudisha the path to its .py file.

    The .pyc file does sio need to exist; this simply returns the path to
    the .py file calculated to correspond to the .pyc file.  If path does
    sio conform to PEP 3147/488 format, ValueError will be raised. If
    sys.implementation.cache_tag ni Tupu then NotImplementedError ni raised.

    """
    ikiwa sys.implementation.cache_tag ni Tupu:
        ashiria NotImplementedError('sys.implementation.cache_tag ni Tupu')
    path = _os.fspath(path)
    head, pycache_filename = _path_split(path)
    found_in_pycache_prefix = Uongo
    ikiwa sys.pycache_prefix ni sio Tupu:
        stripped_path = sys.pycache_prefix.rstrip(path_separators)
        ikiwa head.startswith(stripped_path + path_sep):
            head = head[len(stripped_path):]
            found_in_pycache_prefix = Kweli
    ikiwa sio found_in_pycache_prefix:
        head, pycache = _path_split(head)
        ikiwa pycache != _PYCACHE:
            ashiria ValueError(f'{_PYCACHE} sio bottom-level directory kwenye '
                             f'{path!r}')
    dot_count = pycache_filename.count('.')
    ikiwa dot_count haiko kwenye {2, 3}:
        ashiria ValueError(f'expected only 2 ama 3 dots kwenye {pycache_filename!r}')
    lasivyo dot_count == 3:
        optimization = pycache_filename.rsplit('.', 2)[-2]
        ikiwa sio optimization.startswith(_OPT):
            ashiria ValueError("optimization portion of filename does sio start "
                             f"ukijumuisha {_OPT!r}")
        opt_level = optimization[len(_OPT):]
        ikiwa sio opt_level.isalnum():
            ashiria ValueError(f"optimization level {optimization!r} ni sio an "
                             "alphanumeric value")
    base_filename = pycache_filename.partition('.')[0]
    rudisha _path_join(head, base_filename + SOURCE_SUFFIXES[0])


eleza _get_sourcefile(bytecode_path):
    """Convert a bytecode file path to a source path (ikiwa possible).

    This function exists purely kila backwards-compatibility for
    PyImport_ExecCodeModuleWithFilenames() kwenye the C API.

    """
    ikiwa len(bytecode_path) == 0:
        rudisha Tupu
    rest, _, extension = bytecode_path.rpartition('.')
    ikiwa sio rest ama extension.lower()[-3:-1] != 'py':
        rudisha bytecode_path
    jaribu:
        source_path = source_from_cache(bytecode_path)
    tatizo (NotImplementedError, ValueError):
        source_path = bytecode_path[:-1]
    rudisha source_path ikiwa _path_isfile(source_path) isipokua bytecode_path


eleza _get_cached(filename):
    ikiwa filename.endswith(tuple(SOURCE_SUFFIXES)):
        jaribu:
            rudisha cache_from_source(filename)
        tatizo NotImplementedError:
            pita
    lasivyo filename.endswith(tuple(BYTECODE_SUFFIXES)):
        rudisha filename
    isipokua:
        rudisha Tupu


eleza _calc_mode(path):
    """Calculate the mode permissions kila a bytecode file."""
    jaribu:
        mode = _path_stat(path).st_mode
    tatizo OSError:
        mode = 0o666
    # We always ensure write access so we can update cached files
    # later even when the source files are read-only on Windows (#6074)
    mode |= 0o200
    rudisha mode


eleza _check_name(method):
    """Decorator to verify that the module being requested matches the one the
    loader can handle.

    The first argument (self) must define _name which the second argument is
    compared against. If the comparison fails then ImportError ni raised.

    """
    eleza _check_name_wrapper(self, name=Tupu, *args, **kwargs):
        ikiwa name ni Tupu:
            name = self.name
        lasivyo self.name != name:
            ashiria ImportError('loader kila %s cannot handle %s' %
                                (self.name, name), name=name)
        rudisha method(self, name, *args, **kwargs)
    jaribu:
        _wrap = _bootstrap._wrap
    tatizo NameError:
        # XXX yuck
        eleza _wrap(new, old):
            kila replace kwenye ['__module__', '__name__', '__qualname__', '__doc__']:
                ikiwa hasattr(old, replace):
                    setattr(new, replace, getattr(old, replace))
            new.__dict__.update(old.__dict__)
    _wrap(_check_name_wrapper, method)
    rudisha _check_name_wrapper


eleza _find_module_shim(self, fullname):
    """Try to find a loader kila the specified module by delegating to
    self.find_loader().

    This method ni deprecated kwenye favor of finder.find_spec().

    """
    # Call find_loader(). If it returns a string (indicating this
    # ni a namespace package portion), generate a warning na
    # rudisha Tupu.
    loader, portions = self.find_loader(fullname)
    ikiwa loader ni Tupu na len(portions):
        msg = 'Not importing directory {}: missing __init__'
        _warnings.warn(msg.format(portions[0]), ImportWarning)
    rudisha loader


eleza _classify_pyc(data, name, exc_details):
    """Perform basic validity checking of a pyc header na rudisha the flags field,
    which determines how the pyc should be further validated against the source.

    *data* ni the contents of the pyc file. (Only the first 16 bytes are
    required, though.)

    *name* ni the name of the module being imported. It ni used kila logging.

    *exc_details* ni a dictionary pitaed to ImportError ikiwa it raised for
    improved debugging.

    ImportError ni raised when the magic number ni incorrect ama when the flags
    field ni invalid. EOFError ni raised when the data ni found to be truncated.

    """
    magic = data[:4]
    ikiwa magic != MAGIC_NUMBER:
        message = f'bad magic number kwenye {name!r}: {magic!r}'
        _bootstrap._verbose_message('{}', message)
        ashiria ImportError(message, **exc_details)
    ikiwa len(data) < 16:
        message = f'reached EOF wakati reading pyc header of {name!r}'
        _bootstrap._verbose_message('{}', message)
        ashiria EOFError(message)
    flags = _unpack_uint32(data[4:8])
    # Only the first two flags are defined.
    ikiwa flags & ~0b11:
        message = f'invalid flags {flags!r} kwenye {name!r}'
        ashiria ImportError(message, **exc_details)
    rudisha flags


eleza _validate_timestamp_pyc(data, source_mtime, source_size, name,
                            exc_details):
    """Validate a pyc against the source last-modified time.

    *data* ni the contents of the pyc file. (Only the first 16 bytes are
    required.)

    *source_mtime* ni the last modified timestamp of the source file.

    *source_size* ni Tupu ama the size of the source file kwenye bytes.

    *name* ni the name of the module being imported. It ni used kila logging.

    *exc_details* ni a dictionary pitaed to ImportError ikiwa it raised for
    improved debugging.

    An ImportError ni raised ikiwa the bytecode ni stale.

    """
    ikiwa _unpack_uint32(data[8:12]) != (source_mtime & 0xFFFFFFFF):
        message = f'bytecode ni stale kila {name!r}'
        _bootstrap._verbose_message('{}', message)
        ashiria ImportError(message, **exc_details)
    ikiwa (source_size ni sio Tupu na
        _unpack_uint32(data[12:16]) != (source_size & 0xFFFFFFFF)):
        ashiria ImportError(f'bytecode ni stale kila {name!r}', **exc_details)


eleza _validate_hash_pyc(data, source_hash, name, exc_details):
    """Validate a hash-based pyc by checking the real source hash against the one in
    the pyc header.

    *data* ni the contents of the pyc file. (Only the first 16 bytes are
    required.)

    *source_hash* ni the importlib.util.source_hash() of the source file.

    *name* ni the name of the module being imported. It ni used kila logging.

    *exc_details* ni a dictionary pitaed to ImportError ikiwa it raised for
    improved debugging.

    An ImportError ni raised ikiwa the bytecode ni stale.

    """
    ikiwa data[8:16] != source_hash:
        ashiria ImportError(
            f'hash kwenye bytecode doesn\'t match hash of source {name!r}',
            **exc_details,
        )


eleza _compile_bytecode(data, name=Tupu, bytecode_path=Tupu, source_path=Tupu):
    """Compile bytecode kama found kwenye a pyc."""
    code = marshal.loads(data)
    ikiwa isinstance(code, _code_type):
        _bootstrap._verbose_message('code object kutoka {!r}', bytecode_path)
        ikiwa source_path ni sio Tupu:
            _imp._fix_co_filename(code, source_path)
        rudisha code
    isipokua:
        ashiria ImportError('Non-code object kwenye {!r}'.format(bytecode_path),
                          name=name, path=bytecode_path)


eleza _code_to_timestamp_pyc(code, mtime=0, source_size=0):
    "Produce the data kila a timestamp-based pyc."
    data = bytearray(MAGIC_NUMBER)
    data.extend(_pack_uint32(0))
    data.extend(_pack_uint32(mtime))
    data.extend(_pack_uint32(source_size))
    data.extend(marshal.dumps(code))
    rudisha data


eleza _code_to_hash_pyc(code, source_hash, checked=Kweli):
    "Produce the data kila a hash-based pyc."
    data = bytearray(MAGIC_NUMBER)
    flags = 0b1 | checked << 1
    data.extend(_pack_uint32(flags))
    assert len(source_hash) == 8
    data.extend(source_hash)
    data.extend(marshal.dumps(code))
    rudisha data


eleza decode_source(source_bytes):
    """Decode bytes representing source code na rudisha the string.

    Universal newline support ni used kwenye the decoding.
    """
    agiza tokenize  # To avoid bootstrap issues.
    source_bytes_readline = _io.BytesIO(source_bytes).readline
    encoding = tokenize.detect_encoding(source_bytes_readline)
    newline_decoder = _io.IncrementalNewlineDecoder(Tupu, Kweli)
    rudisha newline_decoder.decode(source_bytes.decode(encoding[0]))


# Module specifications #######################################################

_POPULATE = object()


eleza spec_from_file_location(name, location=Tupu, *, loader=Tupu,
                            submodule_search_locations=_POPULATE):
    """Return a module spec based on a file location.

    To indicate that the module ni a package, set
    submodule_search_locations to a list of directory paths.  An
    empty list ni sufficient, though its sio otherwise useful to the
    agiza system.

    The loader must take a spec kama its only __init__() arg.

    """
    ikiwa location ni Tupu:
        # The caller may simply want a partially populated location-
        # oriented spec.  So we set the location to a bogus value na
        # fill kwenye kama much kama we can.
        location = '<unknown>'
        ikiwa hasattr(loader, 'get_filename'):
            # ExecutionLoader
            jaribu:
                location = loader.get_filename(name)
            tatizo ImportError:
                pita
    isipokua:
        location = _os.fspath(location)

    # If the location ni on the filesystem, but doesn't actually exist,
    # we could rudisha Tupu here, indicating that the location ni not
    # valid.  However, we don't have a good way of testing since an
    # indirect location (e.g. a zip file ama URL) will look like a
    # non-existent file relative to the filesystem.

    spec = _bootstrap.ModuleSpec(name, loader, origin=location)
    spec._set_fileattr = Kweli

    # Pick a loader ikiwa one wasn't provided.
    ikiwa loader ni Tupu:
        kila loader_class, suffixes kwenye _get_supported_file_loaders():
            ikiwa location.endswith(tuple(suffixes)):
                loader = loader_class(name, location)
                spec.loader = loader
                koma
        isipokua:
            rudisha Tupu

    # Set submodule_search_paths appropriately.
    ikiwa submodule_search_locations ni _POPULATE:
        # Check the loader.
        ikiwa hasattr(loader, 'is_package'):
            jaribu:
                is_package = loader.is_package(name)
            tatizo ImportError:
                pita
            isipokua:
                ikiwa is_package:
                    spec.submodule_search_locations = []
    isipokua:
        spec.submodule_search_locations = submodule_search_locations
    ikiwa spec.submodule_search_locations == []:
        ikiwa location:
            dirname = _path_split(location)[0]
            spec.submodule_search_locations.append(dirname)

    rudisha spec


# Loaders #####################################################################

kundi WindowsRegistryFinder:

    """Meta path finder kila modules declared kwenye the Windows registry."""

    REGISTRY_KEY = (
        'Software\\Python\\PythonCore\\{sys_version}'
        '\\Modules\\{fullname}')
    REGISTRY_KEY_DEBUG = (
        'Software\\Python\\PythonCore\\{sys_version}'
        '\\Modules\\{fullname}\\Debug')
    DEBUG_BUILD = Uongo  # Changed kwenye _setup()

    @classmethod
    eleza _open_registry(cls, key):
        jaribu:
            rudisha _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, key)
        tatizo OSError:
            rudisha _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, key)

    @classmethod
    eleza _search_registry(cls, fullname):
        ikiwa cls.DEBUG_BUILD:
            registry_key = cls.REGISTRY_KEY_DEBUG
        isipokua:
            registry_key = cls.REGISTRY_KEY
        key = registry_key.format(fullname=fullname,
                                  sys_version='%d.%d' % sys.version_info[:2])
        jaribu:
            ukijumuisha cls._open_registry(key) kama hkey:
                filepath = _winreg.QueryValue(hkey, '')
        tatizo OSError:
            rudisha Tupu
        rudisha filepath

    @classmethod
    eleza find_spec(cls, fullname, path=Tupu, target=Tupu):
        filepath = cls._search_registry(fullname)
        ikiwa filepath ni Tupu:
            rudisha Tupu
        jaribu:
            _path_stat(filepath)
        tatizo OSError:
            rudisha Tupu
        kila loader, suffixes kwenye _get_supported_file_loaders():
            ikiwa filepath.endswith(tuple(suffixes)):
                spec = _bootstrap.spec_from_loader(fullname,
                                                   loader(fullname, filepath),
                                                   origin=filepath)
                rudisha spec

    @classmethod
    eleza find_module(cls, fullname, path=Tupu):
        """Find module named kwenye the registry.

        This method ni deprecated.  Use exec_module() instead.

        """
        spec = cls.find_spec(fullname, path)
        ikiwa spec ni sio Tupu:
            rudisha spec.loader
        isipokua:
            rudisha Tupu


kundi _LoaderBasics:

    """Base kundi of common code needed by both SourceLoader na
    SourcelessFileLoader."""

    eleza is_package(self, fullname):
        """Concrete implementation of InspectLoader.is_package by checking if
        the path returned by get_filename has a filename of '__init__.py'."""
        filename = _path_split(self.get_filename(fullname))[1]
        filename_base = filename.rsplit('.', 1)[0]
        tail_name = fullname.rpartition('.')[2]
        rudisha filename_base == '__init__' na tail_name != '__init__'

    eleza create_module(self, spec):
        """Use default semantics kila module creation."""

    eleza exec_module(self, module):
        """Execute the module."""
        code = self.get_code(module.__name__)
        ikiwa code ni Tupu:
            ashiria ImportError('cannot load module {!r} when get_code() '
                              'returns Tupu'.format(module.__name__))
        _bootstrap._call_with_frames_removed(exec, code, module.__dict__)

    eleza load_module(self, fullname):
        """This module ni deprecated."""
        rudisha _bootstrap._load_module_shim(self, fullname)


kundi SourceLoader(_LoaderBasics):

    eleza path_mtime(self, path):
        """Optional method that returns the modification time (an int) kila the
        specified path (a str).

        Raises OSError when the path cannot be handled.
        """
        ashiria OSError

    eleza path_stats(self, path):
        """Optional method returning a metadata dict kila the specified
        path (a str).

        Possible keys:
        - 'mtime' (mandatory) ni the numeric timestamp of last source
          code modification;
        - 'size' (optional) ni the size kwenye bytes of the source code.

        Implementing this method allows the loader to read bytecode files.
        Raises OSError when the path cannot be handled.
        """
        rudisha {'mtime': self.path_mtime(path)}

    eleza _cache_bytecode(self, source_path, cache_path, data):
        """Optional method which writes data (bytes) to a file path (a str).

        Implementing this method allows kila the writing of bytecode files.

        The source path ni needed kwenye order to correctly transfer permissions
        """
        # For backwards compatibility, we delegate to set_data()
        rudisha self.set_data(cache_path, data)

    eleza set_data(self, path, data):
        """Optional method which writes data (bytes) to a file path (a str).

        Implementing this method allows kila the writing of bytecode files.
        """


    eleza get_source(self, fullname):
        """Concrete implementation of InspectLoader.get_source."""
        path = self.get_filename(fullname)
        jaribu:
            source_bytes = self.get_data(path)
        tatizo OSError kama exc:
            ashiria ImportError('source sio available through get_data()',
                              name=fullname) kutoka exc
        rudisha decode_source(source_bytes)

    eleza source_to_code(self, data, path, *, _optimize=-1):
        """Return the code object compiled kutoka source.

        The 'data' argument can be any object type that compile() supports.
        """
        rudisha _bootstrap._call_with_frames_removed(compile, data, path, 'exec',
                                        dont_inherit=Kweli, optimize=_optimize)

    eleza get_code(self, fullname):
        """Concrete implementation of InspectLoader.get_code.

        Reading of bytecode requires path_stats to be implemented. To write
        bytecode, set_data must also be implemented.

        """
        source_path = self.get_filename(fullname)
        source_mtime = Tupu
        source_bytes = Tupu
        source_hash = Tupu
        hash_based = Uongo
        check_source = Kweli
        jaribu:
            bytecode_path = cache_from_source(source_path)
        tatizo NotImplementedError:
            bytecode_path = Tupu
        isipokua:
            jaribu:
                st = self.path_stats(source_path)
            tatizo OSError:
                pita
            isipokua:
                source_mtime = int(st['mtime'])
                jaribu:
                    data = self.get_data(bytecode_path)
                tatizo OSError:
                    pita
                isipokua:
                    exc_details = {
                        'name': fullname,
                        'path': bytecode_path,
                    }
                    jaribu:
                        flags = _classify_pyc(data, fullname, exc_details)
                        bytes_data = memoryview(data)[16:]
                        hash_based = flags & 0b1 != 0
                        ikiwa hash_based:
                            check_source = flags & 0b10 != 0
                            ikiwa (_imp.check_hash_based_pycs != 'never' na
                                (check_source ama
                                 _imp.check_hash_based_pycs == 'always')):
                                source_bytes = self.get_data(source_path)
                                source_hash = _imp.source_hash(
                                    _RAW_MAGIC_NUMBER,
                                    source_bytes,
                                )
                                _validate_hash_pyc(data, source_hash, fullname,
                                                   exc_details)
                        isipokua:
                            _validate_timestamp_pyc(
                                data,
                                source_mtime,
                                st['size'],
                                fullname,
                                exc_details,
                            )
                    tatizo (ImportError, EOFError):
                        pita
                    isipokua:
                        _bootstrap._verbose_message('{} matches {}', bytecode_path,
                                                    source_path)
                        rudisha _compile_bytecode(bytes_data, name=fullname,
                                                 bytecode_path=bytecode_path,
                                                 source_path=source_path)
        ikiwa source_bytes ni Tupu:
            source_bytes = self.get_data(source_path)
        code_object = self.source_to_code(source_bytes, source_path)
        _bootstrap._verbose_message('code object kutoka {}', source_path)
        ikiwa (sio sys.dont_write_bytecode na bytecode_path ni sio Tupu na
                source_mtime ni sio Tupu):
            ikiwa hash_based:
                ikiwa source_hash ni Tupu:
                    source_hash = _imp.source_hash(source_bytes)
                data = _code_to_hash_pyc(code_object, source_hash, check_source)
            isipokua:
                data = _code_to_timestamp_pyc(code_object, source_mtime,
                                              len(source_bytes))
            jaribu:
                self._cache_bytecode(source_path, bytecode_path, data)
            tatizo NotImplementedError:
                pita
        rudisha code_object


kundi FileLoader:

    """Base file loader kundi which implements the loader protocol methods that
    require file system usage."""

    eleza __init__(self, fullname, path):
        """Cache the module name na the path to the file found by the
        finder."""
        self.name = fullname
        self.path = path

    eleza __eq__(self, other):
        rudisha (self.__class__ == other.__class__ na
                self.__dict__ == other.__dict__)

    eleza __hash__(self):
        rudisha hash(self.name) ^ hash(self.path)

    @_check_name
    eleza load_module(self, fullname):
        """Load a module kutoka a file.

        This method ni deprecated.  Use exec_module() instead.

        """
        # The only reason kila this method ni kila the name check.
        # Issue #14857: Avoid the zero-argument form of super so the implementation
        # of that form can be updated without komaing the frozen module
        rudisha super(FileLoader, self).load_module(fullname)

    @_check_name
    eleza get_filename(self, fullname):
        """Return the path to the source file kama found by the finder."""
        rudisha self.path

    eleza get_data(self, path):
        """Return the data kutoka path kama raw bytes."""
        ikiwa isinstance(self, (SourceLoader, ExtensionFileLoader)):
            ukijumuisha _io.open_code(str(path)) kama file:
                rudisha file.read()
        isipokua:
            ukijumuisha _io.FileIO(path, 'r') kama file:
                rudisha file.read()

    # ResourceReader ABC API.

    @_check_name
    eleza get_resource_reader(self, module):
        ikiwa self.is_package(module):
            rudisha self
        rudisha Tupu

    eleza open_resource(self, resource):
        path = _path_join(_path_split(self.path)[0], resource)
        rudisha _io.FileIO(path, 'r')

    eleza resource_path(self, resource):
        ikiwa sio self.is_resource(resource):
            ashiria FileNotFoundError
        path = _path_join(_path_split(self.path)[0], resource)
        rudisha path

    eleza is_resource(self, name):
        ikiwa path_sep kwenye name:
            rudisha Uongo
        path = _path_join(_path_split(self.path)[0], name)
        rudisha _path_isfile(path)

    eleza contents(self):
        rudisha iter(_os.listdir(_path_split(self.path)[0]))


kundi SourceFileLoader(FileLoader, SourceLoader):

    """Concrete implementation of SourceLoader using the file system."""

    eleza path_stats(self, path):
        """Return the metadata kila the path."""
        st = _path_stat(path)
        rudisha {'mtime': st.st_mtime, 'size': st.st_size}

    eleza _cache_bytecode(self, source_path, bytecode_path, data):
        # Adapt between the two APIs
        mode = _calc_mode(source_path)
        rudisha self.set_data(bytecode_path, data, _mode=mode)

    eleza set_data(self, path, data, *, _mode=0o666):
        """Write bytes data to a file."""
        parent, filename = _path_split(path)
        path_parts = []
        # Figure out what directories are missing.
        wakati parent na sio _path_isdir(parent):
            parent, part = _path_split(parent)
            path_parts.append(part)
        # Create needed directories.
        kila part kwenye reversed(path_parts):
            parent = _path_join(parent, part)
            jaribu:
                _os.mkdir(parent)
            tatizo FileExistsError:
                # Probably another Python process already created the dir.
                endelea
            tatizo OSError kama exc:
                # Could be a permission error, read-only filesystem: just forget
                # about writing the data.
                _bootstrap._verbose_message('could sio create {!r}: {!r}',
                                            parent, exc)
                rudisha
        jaribu:
            _write_atomic(path, data, _mode)
            _bootstrap._verbose_message('created {!r}', path)
        tatizo OSError kama exc:
            # Same kama above: just don't write the bytecode.
            _bootstrap._verbose_message('could sio create {!r}: {!r}', path,
                                        exc)


kundi SourcelessFileLoader(FileLoader, _LoaderBasics):

    """Loader which handles sourceless file imports."""

    eleza get_code(self, fullname):
        path = self.get_filename(fullname)
        data = self.get_data(path)
        # Call _classify_pyc to do basic validation of the pyc but ignore the
        # result. There's no source to check against.
        exc_details = {
            'name': fullname,
            'path': path,
        }
        _classify_pyc(data, fullname, exc_details)
        rudisha _compile_bytecode(
            memoryview(data)[16:],
            name=fullname,
            bytecode_path=path,
        )

    eleza get_source(self, fullname):
        """Return Tupu kama there ni no source code."""
        rudisha Tupu


# Filled kwenye by _setup().
EXTENSION_SUFFIXES = []


kundi ExtensionFileLoader(FileLoader, _LoaderBasics):

    """Loader kila extension modules.

    The constructor ni designed to work ukijumuisha FileFinder.

    """

    eleza __init__(self, name, path):
        self.name = name
        self.path = path

    eleza __eq__(self, other):
        rudisha (self.__class__ == other.__class__ na
                self.__dict__ == other.__dict__)

    eleza __hash__(self):
        rudisha hash(self.name) ^ hash(self.path)

    eleza create_module(self, spec):
        """Create an unitialized extension module"""
        module = _bootstrap._call_with_frames_removed(
            _imp.create_dynamic, spec)
        _bootstrap._verbose_message('extension module {!r} loaded kutoka {!r}',
                         spec.name, self.path)
        rudisha module

    eleza exec_module(self, module):
        """Initialize an extension module"""
        _bootstrap._call_with_frames_removed(_imp.exec_dynamic, module)
        _bootstrap._verbose_message('extension module {!r} executed kutoka {!r}',
                         self.name, self.path)

    eleza is_package(self, fullname):
        """Return Kweli ikiwa the extension module ni a package."""
        file_name = _path_split(self.path)[1]
        rudisha any(file_name == '__init__' + suffix
                   kila suffix kwenye EXTENSION_SUFFIXES)

    eleza get_code(self, fullname):
        """Return Tupu kama an extension module cannot create a code object."""
        rudisha Tupu

    eleza get_source(self, fullname):
        """Return Tupu kama extension modules have no source code."""
        rudisha Tupu

    @_check_name
    eleza get_filename(self, fullname):
        """Return the path to the source file kama found by the finder."""
        rudisha self.path


kundi _NamespacePath:
    """Represents a namespace package's path.  It uses the module name
    to find its parent module, na kutoka there it looks up the parent's
    __path__.  When this changes, the module's own path ni recomputed,
    using path_finder.  For top-level modules, the parent module's path
    ni sys.path."""

    eleza __init__(self, name, path, path_finder):
        self._name = name
        self._path = path
        self._last_parent_path = tuple(self._get_parent_path())
        self._path_finder = path_finder

    eleza _find_parent_path_names(self):
        """Returns a tuple of (parent-module-name, parent-path-attr-name)"""
        parent, dot, me = self._name.rpartition('.')
        ikiwa dot == '':
            # This ni a top-level module. sys.path contains the parent path.
            rudisha 'sys', 'path'
        # Not a top-level module. parent-module.__path__ contains the
        #  parent path.
        rudisha parent, '__path__'

    eleza _get_parent_path(self):
        parent_module_name, path_attr_name = self._find_parent_path_names()
        rudisha getattr(sys.modules[parent_module_name], path_attr_name)

    eleza _recalculate(self):
        # If the parent's path has changed, recalculate _path
        parent_path = tuple(self._get_parent_path()) # Make a copy
        ikiwa parent_path != self._last_parent_path:
            spec = self._path_finder(self._name, parent_path)
            # Note that no changes are made ikiwa a loader ni returned, but we
            #  do remember the new parent path
            ikiwa spec ni sio Tupu na spec.loader ni Tupu:
                ikiwa spec.submodule_search_locations:
                    self._path = spec.submodule_search_locations
            self._last_parent_path = parent_path     # Save the copy
        rudisha self._path

    eleza __iter__(self):
        rudisha iter(self._recalculate())

    eleza __getitem__(self, index):
        rudisha self._recalculate()[index]

    eleza __setitem__(self, index, path):
        self._path[index] = path

    eleza __len__(self):
        rudisha len(self._recalculate())

    eleza __repr__(self):
        rudisha '_NamespacePath({!r})'.format(self._path)

    eleza __contains__(self, item):
        rudisha item kwenye self._recalculate()

    eleza append(self, item):
        self._path.append(item)


# We use this exclusively kwenye module_from_spec() kila backward-compatibility.
kundi _NamespaceLoader:
    eleza __init__(self, name, path, path_finder):
        self._path = _NamespacePath(name, path, path_finder)

    @classmethod
    eleza module_repr(cls, module):
        """Return repr kila the module.

        The method ni deprecated.  The agiza machinery does the job itself.

        """
        rudisha '<module {!r} (namespace)>'.format(module.__name__)

    eleza is_package(self, fullname):
        rudisha Kweli

    eleza get_source(self, fullname):
        rudisha ''

    eleza get_code(self, fullname):
        rudisha compile('', '<string>', 'exec', dont_inherit=Kweli)

    eleza create_module(self, spec):
        """Use default semantics kila module creation."""

    eleza exec_module(self, module):
        pita

    eleza load_module(self, fullname):
        """Load a namespace module.

        This method ni deprecated.  Use exec_module() instead.

        """
        # The agiza system never calls this method.
        _bootstrap._verbose_message('namespace module loaded ukijumuisha path {!r}',
                                    self._path)
        rudisha _bootstrap._load_module_shim(self, fullname)


# Finders #####################################################################

kundi PathFinder:

    """Meta path finder kila sys.path na package __path__ attributes."""

    @classmethod
    eleza invalidate_caches(cls):
        """Call the invalidate_caches() method on all path entry finders
        stored kwenye sys.path_importer_caches (where implemented)."""
        kila name, finder kwenye list(sys.path_importer_cache.items()):
            ikiwa finder ni Tupu:
                toa sys.path_importer_cache[name]
            lasivyo hasattr(finder, 'invalidate_caches'):
                finder.invalidate_caches()

    @classmethod
    eleza _path_hooks(cls, path):
        """Search sys.path_hooks kila a finder kila 'path'."""
        ikiwa sys.path_hooks ni sio Tupu na sio sys.path_hooks:
            _warnings.warn('sys.path_hooks ni empty', ImportWarning)
        kila hook kwenye sys.path_hooks:
            jaribu:
                rudisha hook(path)
            tatizo ImportError:
                endelea
        isipokua:
            rudisha Tupu

    @classmethod
    eleza _path_importer_cache(cls, path):
        """Get the finder kila the path entry kutoka sys.path_importer_cache.

        If the path entry ni haiko kwenye the cache, find the appropriate finder
        na cache it. If no finder ni available, store Tupu.

        """
        ikiwa path == '':
            jaribu:
                path = _os.getcwd()
            tatizo FileNotFoundError:
                # Don't cache the failure kama the cwd can easily change to
                # a valid directory later on.
                rudisha Tupu
        jaribu:
            finder = sys.path_importer_cache[path]
        tatizo KeyError:
            finder = cls._path_hooks(path)
            sys.path_importer_cache[path] = finder
        rudisha finder

    @classmethod
    eleza _legacy_get_spec(cls, fullname, finder):
        # This would be a good place kila a DeprecationWarning if
        # we ended up going that route.
        ikiwa hasattr(finder, 'find_loader'):
            loader, portions = finder.find_loader(fullname)
        isipokua:
            loader = finder.find_module(fullname)
            portions = []
        ikiwa loader ni sio Tupu:
            rudisha _bootstrap.spec_from_loader(fullname, loader)
        spec = _bootstrap.ModuleSpec(fullname, Tupu)
        spec.submodule_search_locations = portions
        rudisha spec

    @classmethod
    eleza _get_spec(cls, fullname, path, target=Tupu):
        """Find the loader ama namespace_path kila this module/package name."""
        # If this ends up being a namespace package, namespace_path is
        #  the list of paths that will become its __path__
        namespace_path = []
        kila entry kwenye path:
            ikiwa sio isinstance(entry, (str, bytes)):
                endelea
            finder = cls._path_importer_cache(entry)
            ikiwa finder ni sio Tupu:
                ikiwa hasattr(finder, 'find_spec'):
                    spec = finder.find_spec(fullname, target)
                isipokua:
                    spec = cls._legacy_get_spec(fullname, finder)
                ikiwa spec ni Tupu:
                    endelea
                ikiwa spec.loader ni sio Tupu:
                    rudisha spec
                portions = spec.submodule_search_locations
                ikiwa portions ni Tupu:
                    ashiria ImportError('spec missing loader')
                # This ni possibly part of a namespace package.
                #  Remember these path entries (ikiwa any) kila when we
                #  create a namespace package, na endelea iterating
                #  on path.
                namespace_path.extend(portions)
        isipokua:
            spec = _bootstrap.ModuleSpec(fullname, Tupu)
            spec.submodule_search_locations = namespace_path
            rudisha spec

    @classmethod
    eleza find_spec(cls, fullname, path=Tupu, target=Tupu):
        """Try to find a spec kila 'fullname' on sys.path ama 'path'.

        The search ni based on sys.path_hooks na sys.path_importer_cache.
        """
        ikiwa path ni Tupu:
            path = sys.path
        spec = cls._get_spec(fullname, path, target)
        ikiwa spec ni Tupu:
            rudisha Tupu
        lasivyo spec.loader ni Tupu:
            namespace_path = spec.submodule_search_locations
            ikiwa namespace_path:
                # We found at least one namespace path.  Return a spec which
                # can create the namespace package.
                spec.origin = Tupu
                spec.submodule_search_locations = _NamespacePath(fullname, namespace_path, cls._get_spec)
                rudisha spec
            isipokua:
                rudisha Tupu
        isipokua:
            rudisha spec

    @classmethod
    eleza find_module(cls, fullname, path=Tupu):
        """find the module on sys.path ama 'path' based on sys.path_hooks na
        sys.path_importer_cache.

        This method ni deprecated.  Use find_spec() instead.

        """
        spec = cls.find_spec(fullname, path)
        ikiwa spec ni Tupu:
            rudisha Tupu
        rudisha spec.loader

    @classmethod
    eleza find_distributions(cls, *args, **kwargs):
        """
        Find distributions.

        Return an iterable of all Distribution instances capable of
        loading the metadata kila packages matching ``context.name``
        (or all names ikiwa ``Tupu`` indicated) along the paths kwenye the list
        of directories ``context.path``.
        """
        kutoka importlib.metadata agiza MetadataPathFinder
        rudisha MetadataPathFinder.find_distributions(*args, **kwargs)


kundi FileFinder:

    """File-based finder.

    Interactions ukijumuisha the file system are cached kila performance, being
    refreshed when the directory the finder ni handling has been modified.

    """

    eleza __init__(self, path, *loader_details):
        """Initialize ukijumuisha the path to search on na a variable number of
        2-tuples containing the loader na the file suffixes the loader
        recognizes."""
        loaders = []
        kila loader, suffixes kwenye loader_details:
            loaders.extend((suffix, loader) kila suffix kwenye suffixes)
        self._loaders = loaders
        # Base (directory) path
        self.path = path ama '.'
        self._path_mtime = -1
        self._path_cache = set()
        self._relaxed_path_cache = set()

    eleza invalidate_caches(self):
        """Invalidate the directory mtime."""
        self._path_mtime = -1

    find_module = _find_module_shim

    eleza find_loader(self, fullname):
        """Try to find a loader kila the specified module, ama the namespace
        package portions. Returns (loader, list-of-portions).

        This method ni deprecated.  Use find_spec() instead.

        """
        spec = self.find_spec(fullname)
        ikiwa spec ni Tupu:
            rudisha Tupu, []
        rudisha spec.loader, spec.submodule_search_locations ama []

    eleza _get_spec(self, loader_class, fullname, path, smsl, target):
        loader = loader_class(fullname, path)
        rudisha spec_from_file_location(fullname, path, loader=loader,
                                       submodule_search_locations=smsl)

    eleza find_spec(self, fullname, target=Tupu):
        """Try to find a spec kila the specified module.

        Returns the matching spec, ama Tupu ikiwa sio found.
        """
        is_namespace = Uongo
        tail_module = fullname.rpartition('.')[2]
        jaribu:
            mtime = _path_stat(self.path ama _os.getcwd()).st_mtime
        tatizo OSError:
            mtime = -1
        ikiwa mtime != self._path_mtime:
            self._fill_cache()
            self._path_mtime = mtime
        # tail_module keeps the original casing, kila __file__ na friends
        ikiwa _relax_case():
            cache = self._relaxed_path_cache
            cache_module = tail_module.lower()
        isipokua:
            cache = self._path_cache
            cache_module = tail_module
        # Check ikiwa the module ni the name of a directory (and thus a package).
        ikiwa cache_module kwenye cache:
            base_path = _path_join(self.path, tail_module)
            kila suffix, loader_class kwenye self._loaders:
                init_filename = '__init__' + suffix
                full_path = _path_join(base_path, init_filename)
                ikiwa _path_isfile(full_path):
                    rudisha self._get_spec(loader_class, fullname, full_path, [base_path], target)
            isipokua:
                # If a namespace package, rudisha the path ikiwa we don't
                #  find a module kwenye the next section.
                is_namespace = _path_isdir(base_path)
        # Check kila a file w/ a proper suffix exists.
        kila suffix, loader_class kwenye self._loaders:
            full_path = _path_join(self.path, tail_module + suffix)
            _bootstrap._verbose_message('trying {}', full_path, verbosity=2)
            ikiwa cache_module + suffix kwenye cache:
                ikiwa _path_isfile(full_path):
                    rudisha self._get_spec(loader_class, fullname, full_path,
                                          Tupu, target)
        ikiwa is_namespace:
            _bootstrap._verbose_message('possible namespace kila {}', base_path)
            spec = _bootstrap.ModuleSpec(fullname, Tupu)
            spec.submodule_search_locations = [base_path]
            rudisha spec
        rudisha Tupu

    eleza _fill_cache(self):
        """Fill the cache of potential modules na packages kila this directory."""
        path = self.path
        jaribu:
            contents = _os.listdir(path ama _os.getcwd())
        tatizo (FileNotFoundError, PermissionError, NotADirectoryError):
            # Directory has either been removed, turned into a file, ama made
            # unreadable.
            contents = []
        # We store two cached versions, to handle runtime changes of the
        # PYTHONCASEOK environment variable.
        ikiwa sio sys.platform.startswith('win'):
            self._path_cache = set(contents)
        isipokua:
            # Windows users can agiza modules ukijumuisha case-insensitive file
            # suffixes (kila legacy reasons). Make the suffix lowercase here
            # so it's done once instead of kila every import. This ni safe as
            # the specified suffixes to check against are always specified kwenye a
            # case-sensitive manner.
            lower_suffix_contents = set()
            kila item kwenye contents:
                name, dot, suffix = item.partition('.')
                ikiwa dot:
                    new_name = '{}.{}'.format(name, suffix.lower())
                isipokua:
                    new_name = name
                lower_suffix_contents.add(new_name)
            self._path_cache = lower_suffix_contents
        ikiwa sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):
            self._relaxed_path_cache = {fn.lower() kila fn kwenye contents}

    @classmethod
    eleza path_hook(cls, *loader_details):
        """A kundi method which returns a closure to use on sys.path_hook
        which will rudisha an instance using the specified loaders na the path
        called on the closure.

        If the path called on the closure ni sio a directory, ImportError is
        raised.

        """
        eleza path_hook_for_FileFinder(path):
            """Path hook kila importlib.machinery.FileFinder."""
            ikiwa sio _path_isdir(path):
                ashiria ImportError('only directories are supported', path=path)
            rudisha cls(path, *loader_details)

        rudisha path_hook_for_FileFinder

    eleza __repr__(self):
        rudisha 'FileFinder({!r})'.format(self.path)


# Import setup ###############################################################

eleza _fix_up_module(ns, name, pathname, cpathname=Tupu):
    # This function ni used by PyImport_ExecCodeModuleObject().
    loader = ns.get('__loader__')
    spec = ns.get('__spec__')
    ikiwa sio loader:
        ikiwa spec:
            loader = spec.loader
        lasivyo pathname == cpathname:
            loader = SourcelessFileLoader(name, pathname)
        isipokua:
            loader = SourceFileLoader(name, pathname)
    ikiwa sio spec:
        spec = spec_from_file_location(name, pathname, loader=loader)
    jaribu:
        ns['__spec__'] = spec
        ns['__loader__'] = loader
        ns['__file__'] = pathname
        ns['__cached__'] = cpathname
    tatizo Exception:
        # Not important enough to report.
        pita


eleza _get_supported_file_loaders():
    """Returns a list of file-based module loaders.

    Each item ni a tuple (loader, suffixes).
    """
    extensions = ExtensionFileLoader, _imp.extension_suffixes()
    source = SourceFileLoader, SOURCE_SUFFIXES
    bytecode = SourcelessFileLoader, BYTECODE_SUFFIXES
    rudisha [extensions, source, bytecode]


eleza _setup(_bootstrap_module):
    """Setup the path-based importers kila importlib by importing needed
    built-in modules na injecting them into the global namespace.

    Other components are extracted kutoka the core bootstrap module.

    """
    global sys, _imp, _bootstrap
    _bootstrap = _bootstrap_module
    sys = _bootstrap.sys
    _imp = _bootstrap._imp

    # Directly load built-in modules needed during bootstrap.
    self_module = sys.modules[__name__]
    kila builtin_name kwenye ('_io', '_warnings', 'builtins', 'marshal'):
        ikiwa builtin_name haiko kwenye sys.modules:
            builtin_module = _bootstrap._builtin_from_name(builtin_name)
        isipokua:
            builtin_module = sys.modules[builtin_name]
        setattr(self_module, builtin_name, builtin_module)

    # Directly load the os module (needed during bootstrap).
    os_details = ('posix', ['/']), ('nt', ['\\', '/'])
    kila builtin_os, path_separators kwenye os_details:
        # Assumption made kwenye _path_join()
        assert all(len(sep) == 1 kila sep kwenye path_separators)
        path_sep = path_separators[0]
        ikiwa builtin_os kwenye sys.modules:
            os_module = sys.modules[builtin_os]
            koma
        isipokua:
            jaribu:
                os_module = _bootstrap._builtin_from_name(builtin_os)
                koma
            tatizo ImportError:
                endelea
    isipokua:
        ashiria ImportError('importlib requires posix ama nt')
    setattr(self_module, '_os', os_module)
    setattr(self_module, 'path_sep', path_sep)
    setattr(self_module, 'path_separators', ''.join(path_separators))
    setattr(self_module, '_pathseps_with_colon', {f':{s}' kila s kwenye path_separators})

    # Directly load the _thread module (needed during bootstrap).
    thread_module = _bootstrap._builtin_from_name('_thread')
    setattr(self_module, '_thread', thread_module)

    # Directly load the _weakref module (needed during bootstrap).
    weakref_module = _bootstrap._builtin_from_name('_weakref')
    setattr(self_module, '_weakref', weakref_module)

    # Directly load the winreg module (needed during bootstrap).
    ikiwa builtin_os == 'nt':
        winreg_module = _bootstrap._builtin_from_name('winreg')
        setattr(self_module, '_winreg', winreg_module)

    # Constants
    setattr(self_module, '_relax_case', _make_relax_case())
    EXTENSION_SUFFIXES.extend(_imp.extension_suffixes())
    ikiwa builtin_os == 'nt':
        SOURCE_SUFFIXES.append('.pyw')
        ikiwa '_d.pyd' kwenye EXTENSION_SUFFIXES:
            WindowsRegistryFinder.DEBUG_BUILD = Kweli


eleza _install(_bootstrap_module):
    """Install the path-based agiza components."""
    _setup(_bootstrap_module)
    supported_loaders = _get_supported_file_loaders()
    sys.path_hooks.extend([FileFinder.path_hook(*supported_loaders)])
    sys.meta_path.append(PathFinder)
