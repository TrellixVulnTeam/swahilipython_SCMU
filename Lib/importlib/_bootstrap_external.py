"""Core implementation of path-based agiza.

This module is NOT meant to be directly imported! It has been designed such
that it can be bootstrapped into Python as the implementation of agiza. As
such it requires the injection of specific modules and attributes in order to
work. One should use importlib as the public-facing version of this module.

"""
# IMPORTANT: Whenever making changes to this module, be sure to run a top-level
# `make regen-importlib` followed by `make` in order to get the frozen version
# of the module updated. Not doing so will result in the Makefile to fail for
# all others who don't have a ./python around to freeze the module in the early
# stages of compilation.
#

# See importlib._setup() for what is injected into the global namespace.

# When editing this code be aware that code executed at agiza time CANNOT
# reference any injected objects! This includes not only global code but also
# anything specified at the kundi level.

# Bootstrap-related code ######################################################
_CASE_INSENSITIVE_PLATFORMS_STR_KEY = 'win',
_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY = 'cygwin', 'darwin'
_CASE_INSENSITIVE_PLATFORMS =  (_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY
                                + _CASE_INSENSITIVE_PLATFORMS_STR_KEY)


eleza _make_relax_case():
    ikiwa sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):
        ikiwa sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS_STR_KEY):
            key = 'PYTHONCASEOK'
        else:
            key = b'PYTHONCASEOK'

        eleza _relax_case():
            """True ikiwa filenames must be checked case-insensitively."""
            rudisha key in _os.environ
    else:
        eleza _relax_case():
            """True ikiwa filenames must be checked case-insensitively."""
            rudisha False
    rudisha _relax_case


eleza _pack_uint32(x):
    """Convert a 32-bit integer to little-endian."""
    rudisha (int(x) & 0xFFFFFFFF).to_bytes(4, 'little')


eleza _unpack_uint32(data):
    """Convert 4 bytes in little-endian to an integer."""
    assert len(data) == 4
    rudisha int.kutoka_bytes(data, 'little')

eleza _unpack_uint16(data):
    """Convert 2 bytes in little-endian to an integer."""
    assert len(data) == 2
    rudisha int.kutoka_bytes(data, 'little')


eleza _path_join(*path_parts):
    """Replacement for os.path.join()."""
    rudisha path_sep.join([part.rstrip(path_separators)
                          for part in path_parts ikiwa part])


eleza _path_split(path):
    """Replacement for os.path.split()."""
    ikiwa len(path_separators) == 1:
        front, _, tail = path.rpartition(path_sep)
        rudisha front, tail
    for x in reversed(path):
        ikiwa x in path_separators:
            front, tail = path.rsplit(x, maxsplit=1)
            rudisha front, tail
    rudisha '', path


eleza _path_stat(path):
    """Stat the path.

    Made a separate function to make it easier to override in experiments
    (e.g. cache stat results).

    """
    rudisha _os.stat(path)


eleza _path_is_mode_type(path, mode):
    """Test whether the path is the specified mode type."""
    try:
        stat_info = _path_stat(path)
    except OSError:
        rudisha False
    rudisha (stat_info.st_mode & 0o170000) == mode


eleza _path_isfile(path):
    """Replacement for os.path.isfile."""
    rudisha _path_is_mode_type(path, 0o100000)


eleza _path_isdir(path):
    """Replacement for os.path.isdir."""
    ikiwa not path:
        path = _os.getcwd()
    rudisha _path_is_mode_type(path, 0o040000)


eleza _path_isabs(path):
    """Replacement for os.path.isabs.

    Considers a Windows drive-relative path (no drive, but starts with slash) to
    still be "absolute".
    """
    rudisha path.startswith(path_separators) or path[1:3] in _pathseps_with_colon


eleza _write_atomic(path, data, mode=0o666):
    """Best-effort function to write data to a path atomically.
    Be prepared to handle a FileExistsError ikiwa concurrent writing of the
    temporary file is attempted."""
    # id() is used to generate a pseudo-random filename.
    path_tmp = '{}.{}'.format(path, id(path))
    fd = _os.open(path_tmp,
                  _os.O_EXCL | _os.O_CREAT | _os.O_WRONLY, mode & 0o666)
    try:
        # We first write data to a temporary file, and then use os.replace() to
        # perform an atomic rename.
        with _io.FileIO(fd, 'wb') as file:
            file.write(data)
        _os.replace(path_tmp, path)
    except OSError:
        try:
            _os.unlink(path_tmp)
        except OSError:
            pass
        raise


_code_type = type(_write_atomic.__code__)


# Finder/loader utility code ###############################################

# Magic word to reject .pyc files generated by other Python versions.
# It should change for each incompatible change to the bytecode.
#
# The value of CR and LF is incorporated so ikiwa you ever read or write
# a .pyc file in text mode the magic number will be wrong; also, the
# Apple MPW compiler swaps their values, botching string constants.
#
# There were a variety of old schemes for setting the magic number.
# The current working scheme is to increment the previous value by
# 10.
#
# Starting with the adoption of PEP 3147 in Python 3.2, every bump in magic
# number also includes a new "magic tag", i.e. a human readable string used
# to represent the magic number in __pycache__ directories.  When you change
# the magic number, you must also set a new unique magic tag.  Generally this
# can be named after the Python major version of the magic number bump, but
# it can really be anything, as long as it's different than anything else
# that's come before.  The tags are included in the following table, starting
# with Python 3.2a0.
#
# Known values:
#  Python 1.5:   20121
#  Python 1.5.1: 20121
#     Python 1.5.2: 20121
#     Python 1.6:   50428
#     Python 2.0:   50823
#     Python 2.0.1: 50823
#     Python 2.1:   60202
#     Python 2.1.1: 60202
#     Python 2.1.2: 60202
#     Python 2.2:   60717
#     Python 2.3a0: 62011
#     Python 2.3a0: 62021
#     Python 2.3a0: 62011 (!)
#     Python 2.4a0: 62041
#     Python 2.4a3: 62051
#     Python 2.4b1: 62061
#     Python 2.5a0: 62071
#     Python 2.5a0: 62081 (ast-branch)
#     Python 2.5a0: 62091 (with)
#     Python 2.5a0: 62092 (changed WITH_CLEANUP opcode)
#     Python 2.5b3: 62101 (fix wrong code: for x, in ...)
#     Python 2.5b3: 62111 (fix wrong code: x += yield)
#     Python 2.5c1: 62121 (fix wrong lnotab with for loops and
#                          storing constants that should have been removed)
#     Python 2.5c2: 62131 (fix wrong code: for x, in ... in listcomp/genexp)
#     Python 2.6a0: 62151 (peephole optimizations and STORE_MAP opcode)
#     Python 2.6a1: 62161 (WITH_CLEANUP optimization)
#     Python 2.7a0: 62171 (optimize list comprehensions/change LIST_APPEND)
#     Python 2.7a0: 62181 (optimize conditional branches:
#                          introduce POP_JUMP_IF_FALSE and POP_JUMP_IF_TRUE)
#     Python 2.7a0  62191 (introduce SETUP_WITH)
#     Python 2.7a0  62201 (introduce BUILD_SET)
#     Python 2.7a0  62211 (introduce MAP_ADD and SET_ADD)
#     Python 3000:   3000
#                    3010 (removed UNARY_CONVERT)
#                    3020 (added BUILD_SET)
#                    3030 (added keyword-only parameters)
#                    3040 (added signature annotations)
#                    3050 (print becomes a function)
#                    3060 (PEP 3115 metakundi syntax)
#                    3061 (string literals become unicode)
#                    3071 (PEP 3109 raise changes)
#                    3081 (PEP 3137 make __file__ and __name__ unicode)
#                    3091 (kill str8 interning)
#                    3101 (merge kutoka 2.6a0, see 62151)
#                    3103 (__file__ points to source file)
#     Python 3.0a4: 3111 (WITH_CLEANUP optimization).
#     Python 3.0b1: 3131 (lexical exception stacking, including POP_EXCEPT
                          #3021)
#     Python 3.1a1: 3141 (optimize list, set and dict comprehensions:
#                         change LIST_APPEND and SET_ADD, add MAP_ADD #2183)
#     Python 3.1a1: 3151 (optimize conditional branches:
#                         introduce POP_JUMP_IF_FALSE and POP_JUMP_IF_TRUE
                          #4715)
#     Python 3.2a1: 3160 (add SETUP_WITH #6101)
#                   tag: cpython-32
#     Python 3.2a2: 3170 (add DUP_TOP_TWO, remove DUP_TOPX and ROT_FOUR #9225)
#                   tag: cpython-32
#     Python 3.2a3  3180 (add DELETE_DEREF #4617)
#     Python 3.3a1  3190 (__class__ super closure changed)
#     Python 3.3a1  3200 (PEP 3155 __qualname__ added #13448)
#     Python 3.3a1  3210 (added size modulo 2**32 to the pyc header #13645)
#     Python 3.3a2  3220 (changed PEP 380 implementation #14230)
#     Python 3.3a4  3230 (revert changes to implicit __class__ closure #14857)
#     Python 3.4a1  3250 (evaluate positional default arguments before
#                        keyword-only defaults #16967)
#     Python 3.4a1  3260 (add LOAD_CLASSDEREF; allow locals of kundi to override
#                        free vars #17853)
#     Python 3.4a1  3270 (various tweaks to the __class__ closure #12370)
#     Python 3.4a1  3280 (remove implicit kundi argument)
#     Python 3.4a4  3290 (changes to __qualname__ computation #19301)
#     Python 3.4a4  3300 (more changes to __qualname__ computation #19301)
#     Python 3.4rc2 3310 (alter __qualname__ computation #20625)
#     Python 3.5a1  3320 (PEP 465: Matrix multiplication operator #21176)
#     Python 3.5b1  3330 (PEP 448: Additional Unpacking Generalizations #2292)
#     Python 3.5b2  3340 (fix dictionary display evaluation order #11205)
#     Python 3.5b3  3350 (add GET_YIELD_FROM_ITER opcode #24400)
#     Python 3.5.2  3351 (fix BUILD_MAP_UNPACK_WITH_CALL opcode #27286)
#     Python 3.6a0  3360 (add FORMAT_VALUE opcode #25483)
#     Python 3.6a1  3361 (lineno delta of code.co_lnotab becomes signed #26107)
#     Python 3.6a2  3370 (16 bit wordcode #26647)
#     Python 3.6a2  3371 (add BUILD_CONST_KEY_MAP opcode #27140)
#     Python 3.6a2  3372 (MAKE_FUNCTION simplification, remove MAKE_CLOSURE
#                         #27095)
#     Python 3.6b1  3373 (add BUILD_STRING opcode #27078)
#     Python 3.6b1  3375 (add SETUP_ANNOTATIONS and STORE_ANNOTATION opcodes
#                         #27985)
#     Python 3.6b1  3376 (simplify CALL_FUNCTIONs & BUILD_MAP_UNPACK_WITH_CALL
                          #27213)
#     Python 3.6b1  3377 (set __class__ cell kutoka type.__new__ #23722)
#     Python 3.6b2  3378 (add BUILD_TUPLE_UNPACK_WITH_CALL #28257)
#     Python 3.6rc1 3379 (more thorough __class__ validation #23722)
#     Python 3.7a1  3390 (add LOAD_METHOD and CALL_METHOD opcodes #26110)
#     Python 3.7a2  3391 (update GET_AITER #31709)
#     Python 3.7a4  3392 (PEP 552: Deterministic pycs #31650)
#     Python 3.7b1  3393 (remove STORE_ANNOTATION opcode #32550)
#     Python 3.7b5  3394 (restored docstring as the first stmt in the body;
#                         this might affected the first line number #32911)
#     Python 3.8a1  3400 (move frame block handling to compiler #17611)
#     Python 3.8a1  3401 (add END_ASYNC_FOR #33041)
#     Python 3.8a1  3410 (PEP570 Python Positional-Only Parameters #36540)
#     Python 3.8b2  3411 (Reverse evaluation order of key: value in dict
#                         comprehensions #35224)
#     Python 3.8b2  3412 (Swap the position of positional args and positional
#                         only args in ast.arguments #37593)
#     Python 3.8b4  3413 (Fix "break" and "continue" in "finally" #37830)
#
# MAGIC must change whenever the bytecode emitted by the compiler may no
# longer be understood by older implementations of the eval loop (usually
# due to the addition of new opcodes).
#
# Whenever MAGIC_NUMBER is changed, the ranges in the magic_values array
# in PC/launcher.c must also be updated.

MAGIC_NUMBER = (3413).to_bytes(2, 'little') + b'\r\n'
_RAW_MAGIC_NUMBER = int.kutoka_bytes(MAGIC_NUMBER, 'little')  # For agiza.c

_PYCACHE = '__pycache__'
_OPT = 'opt-'

SOURCE_SUFFIXES = ['.py']  # _setup() adds .pyw as needed.

BYTECODE_SUFFIXES = ['.pyc']
# Deprecated.
DEBUG_BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES = BYTECODE_SUFFIXES

eleza cache_kutoka_source(path, debug_override=None, *, optimization=None):
    """Given the path to a .py file, rudisha the path to its .pyc file.

    The .py file does not need to exist; this simply returns the path to the
    .pyc file calculated as ikiwa the .py file were imported.

    The 'optimization' parameter controls the presumed optimization level of
    the bytecode file. If 'optimization' is not None, the string representation
    of the argument is taken and verified to be alphanumeric (else ValueError
    is raised).

    The debug_override parameter is deprecated. If debug_override is not None,
    a True value is the same as setting 'optimization' to the empty string
    while a False value is equivalent to setting 'optimization' to '1'.

    If sys.implementation.cache_tag is None then NotImplementedError is raised.

    """
    ikiwa debug_override is not None:
        _warnings.warn('the debug_override parameter is deprecated; use '
                       "'optimization' instead", DeprecationWarning)
        ikiwa optimization is not None:
            message = 'debug_override or optimization must be set to None'
            raise TypeError(message)
        optimization = '' ikiwa debug_override else 1
    path = _os.fspath(path)
    head, tail = _path_split(path)
    base, sep, rest = tail.rpartition('.')
    tag = sys.implementation.cache_tag
    ikiwa tag is None:
        raise NotImplementedError('sys.implementation.cache_tag is None')
    almost_filename = ''.join([(base ikiwa base else rest), sep, tag])
    ikiwa optimization is None:
        ikiwa sys.flags.optimize == 0:
            optimization = ''
        else:
            optimization = sys.flags.optimize
    optimization = str(optimization)
    ikiwa optimization != '':
        ikiwa not optimization.isalnum():
            raise ValueError('{!r} is not alphanumeric'.format(optimization))
        almost_filename = '{}.{}{}'.format(almost_filename, _OPT, optimization)
    filename = almost_filename + BYTECODE_SUFFIXES[0]
    ikiwa sys.pycache_prefix is not None:
        # We need an absolute path to the py file to avoid the possibility of
        # collisions within sys.pycache_prefix, ikiwa someone has two different
        # `foo/bar.py` on their system and they agiza both of them using the
        # same sys.pycache_prefix. Let's say sys.pycache_prefix is
        # `C:\Bytecode`; the idea here is that ikiwa we get `Foo\Bar`, we first
        # make it absolute (`C:\Somewhere\Foo\Bar`), then make it root-relative
        # (`Somewhere\Foo\Bar`), so we end up placing the bytecode file in an
        # unambiguous `C:\Bytecode\Somewhere\Foo\Bar\`.
        ikiwa not _path_isabs(head):
            head = _path_join(_os.getcwd(), head)

        # Strip initial drive kutoka a Windows path. We know we have an absolute
        # path here, so the second part of the check rules out a POSIX path that
        # happens to contain a colon at the second character.
        ikiwa head[1] == ':' and head[0] not in path_separators:
            head = head[2:]

        # Strip initial path separator kutoka `head` to complete the conversion
        # back to a root-relative path before joining.
        rudisha _path_join(
            sys.pycache_prefix,
            head.lstrip(path_separators),
            filename,
        )
    rudisha _path_join(head, _PYCACHE, filename)


eleza source_kutoka_cache(path):
    """Given the path to a .pyc. file, rudisha the path to its .py file.

    The .pyc file does not need to exist; this simply returns the path to
    the .py file calculated to correspond to the .pyc file.  If path does
    not conform to PEP 3147/488 format, ValueError will be raised. If
    sys.implementation.cache_tag is None then NotImplementedError is raised.

    """
    ikiwa sys.implementation.cache_tag is None:
        raise NotImplementedError('sys.implementation.cache_tag is None')
    path = _os.fspath(path)
    head, pycache_filename = _path_split(path)
    found_in_pycache_prefix = False
    ikiwa sys.pycache_prefix is not None:
        stripped_path = sys.pycache_prefix.rstrip(path_separators)
        ikiwa head.startswith(stripped_path + path_sep):
            head = head[len(stripped_path):]
            found_in_pycache_prefix = True
    ikiwa not found_in_pycache_prefix:
        head, pycache = _path_split(head)
        ikiwa pycache != _PYCACHE:
            raise ValueError(f'{_PYCACHE} not bottom-level directory in '
                             f'{path!r}')
    dot_count = pycache_filename.count('.')
    ikiwa dot_count not in {2, 3}:
        raise ValueError(f'expected only 2 or 3 dots in {pycache_filename!r}')
    elikiwa dot_count == 3:
        optimization = pycache_filename.rsplit('.', 2)[-2]
        ikiwa not optimization.startswith(_OPT):
            raise ValueError("optimization portion of filename does not start "
                             f"with {_OPT!r}")
        opt_level = optimization[len(_OPT):]
        ikiwa not opt_level.isalnum():
            raise ValueError(f"optimization level {optimization!r} is not an "
                             "alphanumeric value")
    base_filename = pycache_filename.partition('.')[0]
    rudisha _path_join(head, base_filename + SOURCE_SUFFIXES[0])


eleza _get_sourcefile(bytecode_path):
    """Convert a bytecode file path to a source path (ikiwa possible).

    This function exists purely for backwards-compatibility for
    PyImport_ExecCodeModuleWithFilenames() in the C API.

    """
    ikiwa len(bytecode_path) == 0:
        rudisha None
    rest, _, extension = bytecode_path.rpartition('.')
    ikiwa not rest or extension.lower()[-3:-1] != 'py':
        rudisha bytecode_path
    try:
        source_path = source_kutoka_cache(bytecode_path)
    except (NotImplementedError, ValueError):
        source_path = bytecode_path[:-1]
    rudisha source_path ikiwa _path_isfile(source_path) else bytecode_path


eleza _get_cached(filename):
    ikiwa filename.endswith(tuple(SOURCE_SUFFIXES)):
        try:
            rudisha cache_kutoka_source(filename)
        except NotImplementedError:
            pass
    elikiwa filename.endswith(tuple(BYTECODE_SUFFIXES)):
        rudisha filename
    else:
        rudisha None


eleza _calc_mode(path):
    """Calculate the mode permissions for a bytecode file."""
    try:
        mode = _path_stat(path).st_mode
    except OSError:
        mode = 0o666
    # We always ensure write access so we can update cached files
    # later even when the source files are read-only on Windows (#6074)
    mode |= 0o200
    rudisha mode


eleza _check_name(method):
    """Decorator to verify that the module being requested matches the one the
    loader can handle.

    The first argument (self) must define _name which the second argument is
    compared against. If the comparison fails then ImportError is raised.

    """
    eleza _check_name_wrapper(self, name=None, *args, **kwargs):
        ikiwa name is None:
            name = self.name
        elikiwa self.name != name:
            raise ImportError('loader for %s cannot handle %s' %
                                (self.name, name), name=name)
        rudisha method(self, name, *args, **kwargs)
    try:
        _wrap = _bootstrap._wrap
    except NameError:
        # XXX yuck
        eleza _wrap(new, old):
            for replace in ['__module__', '__name__', '__qualname__', '__doc__']:
                ikiwa hasattr(old, replace):
                    setattr(new, replace, getattr(old, replace))
            new.__dict__.update(old.__dict__)
    _wrap(_check_name_wrapper, method)
    rudisha _check_name_wrapper


eleza _find_module_shim(self, fullname):
    """Try to find a loader for the specified module by delegating to
    self.find_loader().

    This method is deprecated in favor of finder.find_spec().

    """
    # Call find_loader(). If it returns a string (indicating this
    # is a namespace package portion), generate a warning and
    # rudisha None.
    loader, portions = self.find_loader(fullname)
    ikiwa loader is None and len(portions):
        msg = 'Not agizaing directory {}: missing __init__'
        _warnings.warn(msg.format(portions[0]), ImportWarning)
    rudisha loader


eleza _classify_pyc(data, name, exc_details):
    """Perform basic validity checking of a pyc header and rudisha the flags field,
    which determines how the pyc should be further validated against the source.

    *data* is the contents of the pyc file. (Only the first 16 bytes are
    required, though.)

    *name* is the name of the module being imported. It is used for logging.

    *exc_details* is a dictionary passed to ImportError ikiwa it raised for
    improved debugging.

    ImportError is raised when the magic number is incorrect or when the flags
    field is invalid. EOFError is raised when the data is found to be truncated.

    """
    magic = data[:4]
    ikiwa magic != MAGIC_NUMBER:
        message = f'bad magic number in {name!r}: {magic!r}'
        _bootstrap._verbose_message('{}', message)
        raise ImportError(message, **exc_details)
    ikiwa len(data) < 16:
        message = f'reached EOF while reading pyc header of {name!r}'
        _bootstrap._verbose_message('{}', message)
        raise EOFError(message)
    flags = _unpack_uint32(data[4:8])
    # Only the first two flags are defined.
    ikiwa flags & ~0b11:
        message = f'invalid flags {flags!r} in {name!r}'
        raise ImportError(message, **exc_details)
    rudisha flags


eleza _validate_timestamp_pyc(data, source_mtime, source_size, name,
                            exc_details):
    """Validate a pyc against the source last-modified time.

    *data* is the contents of the pyc file. (Only the first 16 bytes are
    required.)

    *source_mtime* is the last modified timestamp of the source file.

    *source_size* is None or the size of the source file in bytes.

    *name* is the name of the module being imported. It is used for logging.

    *exc_details* is a dictionary passed to ImportError ikiwa it raised for
    improved debugging.

    An ImportError is raised ikiwa the bytecode is stale.

    """
    ikiwa _unpack_uint32(data[8:12]) != (source_mtime & 0xFFFFFFFF):
        message = f'bytecode is stale for {name!r}'
        _bootstrap._verbose_message('{}', message)
        raise ImportError(message, **exc_details)
    ikiwa (source_size is not None and
        _unpack_uint32(data[12:16]) != (source_size & 0xFFFFFFFF)):
        raise ImportError(f'bytecode is stale for {name!r}', **exc_details)


eleza _validate_hash_pyc(data, source_hash, name, exc_details):
    """Validate a hash-based pyc by checking the real source hash against the one in
    the pyc header.

    *data* is the contents of the pyc file. (Only the first 16 bytes are
    required.)

    *source_hash* is the importlib.util.source_hash() of the source file.

    *name* is the name of the module being imported. It is used for logging.

    *exc_details* is a dictionary passed to ImportError ikiwa it raised for
    improved debugging.

    An ImportError is raised ikiwa the bytecode is stale.

    """
    ikiwa data[8:16] != source_hash:
        raise ImportError(
            f'hash in bytecode doesn\'t match hash of source {name!r}',
            **exc_details,
        )


eleza _compile_bytecode(data, name=None, bytecode_path=None, source_path=None):
    """Compile bytecode as found in a pyc."""
    code = marshal.loads(data)
    ikiwa isinstance(code, _code_type):
        _bootstrap._verbose_message('code object kutoka {!r}', bytecode_path)
        ikiwa source_path is not None:
            _imp._fix_co_filename(code, source_path)
        rudisha code
    else:
        raise ImportError('Non-code object in {!r}'.format(bytecode_path),
                          name=name, path=bytecode_path)


eleza _code_to_timestamp_pyc(code, mtime=0, source_size=0):
    "Produce the data for a timestamp-based pyc."
    data = bytearray(MAGIC_NUMBER)
    data.extend(_pack_uint32(0))
    data.extend(_pack_uint32(mtime))
    data.extend(_pack_uint32(source_size))
    data.extend(marshal.dumps(code))
    rudisha data


eleza _code_to_hash_pyc(code, source_hash, checked=True):
    "Produce the data for a hash-based pyc."
    data = bytearray(MAGIC_NUMBER)
    flags = 0b1 | checked << 1
    data.extend(_pack_uint32(flags))
    assert len(source_hash) == 8
    data.extend(source_hash)
    data.extend(marshal.dumps(code))
    rudisha data


eleza decode_source(source_bytes):
    """Decode bytes representing source code and rudisha the string.

    Universal newline support is used in the decoding.
    """
    agiza tokenize  # To avoid bootstrap issues.
    source_bytes_readline = _io.BytesIO(source_bytes).readline
    encoding = tokenize.detect_encoding(source_bytes_readline)
    newline_decoder = _io.IncrementalNewlineDecoder(None, True)
    rudisha newline_decoder.decode(source_bytes.decode(encoding[0]))


# Module specifications #######################################################

_POPULATE = object()


eleza spec_kutoka_file_location(name, location=None, *, loader=None,
                            submodule_search_locations=_POPULATE):
    """Return a module spec based on a file location.

    To indicate that the module is a package, set
    submodule_search_locations to a list of directory paths.  An
    empty list is sufficient, though its not otherwise useful to the
    agiza system.

    The loader must take a spec as its only __init__() arg.

    """
    ikiwa location is None:
        # The caller may simply want a partially populated location-
        # oriented spec.  So we set the location to a bogus value and
        # fill in as much as we can.
        location = '<unknown>'
        ikiwa hasattr(loader, 'get_filename'):
            # ExecutionLoader
            try:
                location = loader.get_filename(name)
            except ImportError:
                pass
    else:
        location = _os.fspath(location)

    # If the location is on the filesystem, but doesn't actually exist,
    # we could rudisha None here, indicating that the location is not
    # valid.  However, we don't have a good way of testing since an
    # indirect location (e.g. a zip file or URL) will look like a
    # non-existent file relative to the filesystem.

    spec = _bootstrap.ModuleSpec(name, loader, origin=location)
    spec._set_fileattr = True

    # Pick a loader ikiwa one wasn't provided.
    ikiwa loader is None:
        for loader_class, suffixes in _get_supported_file_loaders():
            ikiwa location.endswith(tuple(suffixes)):
                loader = loader_class(name, location)
                spec.loader = loader
                break
        else:
            rudisha None

    # Set submodule_search_paths appropriately.
    ikiwa submodule_search_locations is _POPULATE:
        # Check the loader.
        ikiwa hasattr(loader, 'is_package'):
            try:
                is_package = loader.is_package(name)
            except ImportError:
                pass
            else:
                ikiwa is_package:
                    spec.submodule_search_locations = []
    else:
        spec.submodule_search_locations = submodule_search_locations
    ikiwa spec.submodule_search_locations == []:
        ikiwa location:
            dirname = _path_split(location)[0]
            spec.submodule_search_locations.append(dirname)

    rudisha spec


# Loaders #####################################################################

kundi WindowsRegistryFinder:

    """Meta path finder for modules declared in the Windows registry."""

    REGISTRY_KEY = (
        'Software\\Python\\PythonCore\\{sys_version}'
        '\\Modules\\{fullname}')
    REGISTRY_KEY_DEBUG = (
        'Software\\Python\\PythonCore\\{sys_version}'
        '\\Modules\\{fullname}\\Debug')
    DEBUG_BUILD = False  # Changed in _setup()

    @classmethod
    eleza _open_registry(cls, key):
        try:
            rudisha _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, key)
        except OSError:
            rudisha _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, key)

    @classmethod
    eleza _search_registry(cls, fullname):
        ikiwa cls.DEBUG_BUILD:
            registry_key = cls.REGISTRY_KEY_DEBUG
        else:
            registry_key = cls.REGISTRY_KEY
        key = registry_key.format(fullname=fullname,
                                  sys_version='%d.%d' % sys.version_info[:2])
        try:
            with cls._open_registry(key) as hkey:
                filepath = _winreg.QueryValue(hkey, '')
        except OSError:
            rudisha None
        rudisha filepath

    @classmethod
    eleza find_spec(cls, fullname, path=None, target=None):
        filepath = cls._search_registry(fullname)
        ikiwa filepath is None:
            rudisha None
        try:
            _path_stat(filepath)
        except OSError:
            rudisha None
        for loader, suffixes in _get_supported_file_loaders():
            ikiwa filepath.endswith(tuple(suffixes)):
                spec = _bootstrap.spec_kutoka_loader(fullname,
                                                   loader(fullname, filepath),
                                                   origin=filepath)
                rudisha spec

    @classmethod
    eleza find_module(cls, fullname, path=None):
        """Find module named in the registry.

        This method is deprecated.  Use exec_module() instead.

        """
        spec = cls.find_spec(fullname, path)
        ikiwa spec is not None:
            rudisha spec.loader
        else:
            rudisha None


kundi _LoaderBasics:

    """Base kundi of common code needed by both SourceLoader and
    SourcelessFileLoader."""

    eleza is_package(self, fullname):
        """Concrete implementation of InspectLoader.is_package by checking if
        the path returned by get_filename has a filename of '__init__.py'."""
        filename = _path_split(self.get_filename(fullname))[1]
        filename_base = filename.rsplit('.', 1)[0]
        tail_name = fullname.rpartition('.')[2]
        rudisha filename_base == '__init__' and tail_name != '__init__'

    eleza create_module(self, spec):
        """Use default semantics for module creation."""

    eleza exec_module(self, module):
        """Execute the module."""
        code = self.get_code(module.__name__)
        ikiwa code is None:
            raise ImportError('cannot load module {!r} when get_code() '
                              'returns None'.format(module.__name__))
        _bootstrap._call_with_frames_removed(exec, code, module.__dict__)

    eleza load_module(self, fullname):
        """This module is deprecated."""
        rudisha _bootstrap._load_module_shim(self, fullname)


kundi SourceLoader(_LoaderBasics):

    eleza path_mtime(self, path):
        """Optional method that returns the modification time (an int) for the
        specified path (a str).

        Raises OSError when the path cannot be handled.
        """
        raise OSError

    eleza path_stats(self, path):
        """Optional method returning a metadata dict for the specified
        path (a str).

        Possible keys:
        - 'mtime' (mandatory) is the numeric timestamp of last source
          code modification;
        - 'size' (optional) is the size in bytes of the source code.

        Implementing this method allows the loader to read bytecode files.
        Raises OSError when the path cannot be handled.
        """
        rudisha {'mtime': self.path_mtime(path)}

    eleza _cache_bytecode(self, source_path, cache_path, data):
        """Optional method which writes data (bytes) to a file path (a str).

        Implementing this method allows for the writing of bytecode files.

        The source path is needed in order to correctly transfer permissions
        """
        # For backwards compatibility, we delegate to set_data()
        rudisha self.set_data(cache_path, data)

    eleza set_data(self, path, data):
        """Optional method which writes data (bytes) to a file path (a str).

        Implementing this method allows for the writing of bytecode files.
        """


    eleza get_source(self, fullname):
        """Concrete implementation of InspectLoader.get_source."""
        path = self.get_filename(fullname)
        try:
            source_bytes = self.get_data(path)
        except OSError as exc:
            raise ImportError('source not available through get_data()',
                              name=fullname) kutoka exc
        rudisha decode_source(source_bytes)

    eleza source_to_code(self, data, path, *, _optimize=-1):
        """Return the code object compiled kutoka source.

        The 'data' argument can be any object type that compile() supports.
        """
        rudisha _bootstrap._call_with_frames_removed(compile, data, path, 'exec',
                                        dont_inherit=True, optimize=_optimize)

    eleza get_code(self, fullname):
        """Concrete implementation of InspectLoader.get_code.

        Reading of bytecode requires path_stats to be implemented. To write
        bytecode, set_data must also be implemented.

        """
        source_path = self.get_filename(fullname)
        source_mtime = None
        source_bytes = None
        source_hash = None
        hash_based = False
        check_source = True
        try:
            bytecode_path = cache_kutoka_source(source_path)
        except NotImplementedError:
            bytecode_path = None
        else:
            try:
                st = self.path_stats(source_path)
            except OSError:
                pass
            else:
                source_mtime = int(st['mtime'])
                try:
                    data = self.get_data(bytecode_path)
                except OSError:
                    pass
                else:
                    exc_details = {
                        'name': fullname,
                        'path': bytecode_path,
                    }
                    try:
                        flags = _classify_pyc(data, fullname, exc_details)
                        bytes_data = memoryview(data)[16:]
                        hash_based = flags & 0b1 != 0
                        ikiwa hash_based:
                            check_source = flags & 0b10 != 0
                            ikiwa (_imp.check_hash_based_pycs != 'never' and
                                (check_source or
                                 _imp.check_hash_based_pycs == 'always')):
                                source_bytes = self.get_data(source_path)
                                source_hash = _imp.source_hash(
                                    _RAW_MAGIC_NUMBER,
                                    source_bytes,
                                )
                                _validate_hash_pyc(data, source_hash, fullname,
                                                   exc_details)
                        else:
                            _validate_timestamp_pyc(
                                data,
                                source_mtime,
                                st['size'],
                                fullname,
                                exc_details,
                            )
                    except (ImportError, EOFError):
                        pass
                    else:
                        _bootstrap._verbose_message('{} matches {}', bytecode_path,
                                                    source_path)
                        rudisha _compile_bytecode(bytes_data, name=fullname,
                                                 bytecode_path=bytecode_path,
                                                 source_path=source_path)
        ikiwa source_bytes is None:
            source_bytes = self.get_data(source_path)
        code_object = self.source_to_code(source_bytes, source_path)
        _bootstrap._verbose_message('code object kutoka {}', source_path)
        ikiwa (not sys.dont_write_bytecode and bytecode_path is not None and
                source_mtime is not None):
            ikiwa hash_based:
                ikiwa source_hash is None:
                    source_hash = _imp.source_hash(source_bytes)
                data = _code_to_hash_pyc(code_object, source_hash, check_source)
            else:
                data = _code_to_timestamp_pyc(code_object, source_mtime,
                                              len(source_bytes))
            try:
                self._cache_bytecode(source_path, bytecode_path, data)
            except NotImplementedError:
                pass
        rudisha code_object


kundi FileLoader:

    """Base file loader kundi which implements the loader protocol methods that
    require file system usage."""

    eleza __init__(self, fullname, path):
        """Cache the module name and the path to the file found by the
        finder."""
        self.name = fullname
        self.path = path

    eleza __eq__(self, other):
        rudisha (self.__class__ == other.__class__ and
                self.__dict__ == other.__dict__)

    eleza __hash__(self):
        rudisha hash(self.name) ^ hash(self.path)

    @_check_name
    eleza load_module(self, fullname):
        """Load a module kutoka a file.

        This method is deprecated.  Use exec_module() instead.

        """
        # The only reason for this method is for the name check.
        # Issue #14857: Avoid the zero-argument form of super so the implementation
        # of that form can be updated without breaking the frozen module
        rudisha super(FileLoader, self).load_module(fullname)

    @_check_name
    eleza get_filename(self, fullname):
        """Return the path to the source file as found by the finder."""
        rudisha self.path

    eleza get_data(self, path):
        """Return the data kutoka path as raw bytes."""
        ikiwa isinstance(self, (SourceLoader, ExtensionFileLoader)):
            with _io.open_code(str(path)) as file:
                rudisha file.read()
        else:
            with _io.FileIO(path, 'r') as file:
                rudisha file.read()

    # ResourceReader ABC API.

    @_check_name
    eleza get_resource_reader(self, module):
        ikiwa self.is_package(module):
            rudisha self
        rudisha None

    eleza open_resource(self, resource):
        path = _path_join(_path_split(self.path)[0], resource)
        rudisha _io.FileIO(path, 'r')

    eleza resource_path(self, resource):
        ikiwa not self.is_resource(resource):
            raise FileNotFoundError
        path = _path_join(_path_split(self.path)[0], resource)
        rudisha path

    eleza is_resource(self, name):
        ikiwa path_sep in name:
            rudisha False
        path = _path_join(_path_split(self.path)[0], name)
        rudisha _path_isfile(path)

    eleza contents(self):
        rudisha iter(_os.listdir(_path_split(self.path)[0]))


kundi SourceFileLoader(FileLoader, SourceLoader):

    """Concrete implementation of SourceLoader using the file system."""

    eleza path_stats(self, path):
        """Return the metadata for the path."""
        st = _path_stat(path)
        rudisha {'mtime': st.st_mtime, 'size': st.st_size}

    eleza _cache_bytecode(self, source_path, bytecode_path, data):
        # Adapt between the two APIs
        mode = _calc_mode(source_path)
        rudisha self.set_data(bytecode_path, data, _mode=mode)

    eleza set_data(self, path, data, *, _mode=0o666):
        """Write bytes data to a file."""
        parent, filename = _path_split(path)
        path_parts = []
        # Figure out what directories are missing.
        while parent and not _path_isdir(parent):
            parent, part = _path_split(parent)
            path_parts.append(part)
        # Create needed directories.
        for part in reversed(path_parts):
            parent = _path_join(parent, part)
            try:
                _os.mkdir(parent)
            except FileExistsError:
                # Probably another Python process already created the dir.
                continue
            except OSError as exc:
                # Could be a permission error, read-only filesystem: just forget
                # about writing the data.
                _bootstrap._verbose_message('could not create {!r}: {!r}',
                                            parent, exc)
                return
        try:
            _write_atomic(path, data, _mode)
            _bootstrap._verbose_message('created {!r}', path)
        except OSError as exc:
            # Same as above: just don't write the bytecode.
            _bootstrap._verbose_message('could not create {!r}: {!r}', path,
                                        exc)


kundi SourcelessFileLoader(FileLoader, _LoaderBasics):

    """Loader which handles sourceless file agizas."""

    eleza get_code(self, fullname):
        path = self.get_filename(fullname)
        data = self.get_data(path)
        # Call _classify_pyc to do basic validation of the pyc but ignore the
        # result. There's no source to check against.
        exc_details = {
            'name': fullname,
            'path': path,
        }
        _classify_pyc(data, fullname, exc_details)
        rudisha _compile_bytecode(
            memoryview(data)[16:],
            name=fullname,
            bytecode_path=path,
        )

    eleza get_source(self, fullname):
        """Return None as there is no source code."""
        rudisha None


# Filled in by _setup().
EXTENSION_SUFFIXES = []


kundi ExtensionFileLoader(FileLoader, _LoaderBasics):

    """Loader for extension modules.

    The constructor is designed to work with FileFinder.

    """

    eleza __init__(self, name, path):
        self.name = name
        self.path = path

    eleza __eq__(self, other):
        rudisha (self.__class__ == other.__class__ and
                self.__dict__ == other.__dict__)

    eleza __hash__(self):
        rudisha hash(self.name) ^ hash(self.path)

    eleza create_module(self, spec):
        """Create an unitialized extension module"""
        module = _bootstrap._call_with_frames_removed(
            _imp.create_dynamic, spec)
        _bootstrap._verbose_message('extension module {!r} loaded kutoka {!r}',
                         spec.name, self.path)
        rudisha module

    eleza exec_module(self, module):
        """Initialize an extension module"""
        _bootstrap._call_with_frames_removed(_imp.exec_dynamic, module)
        _bootstrap._verbose_message('extension module {!r} executed kutoka {!r}',
                         self.name, self.path)

    eleza is_package(self, fullname):
        """Return True ikiwa the extension module is a package."""
        file_name = _path_split(self.path)[1]
        rudisha any(file_name == '__init__' + suffix
                   for suffix in EXTENSION_SUFFIXES)

    eleza get_code(self, fullname):
        """Return None as an extension module cannot create a code object."""
        rudisha None

    eleza get_source(self, fullname):
        """Return None as extension modules have no source code."""
        rudisha None

    @_check_name
    eleza get_filename(self, fullname):
        """Return the path to the source file as found by the finder."""
        rudisha self.path


kundi _NamespacePath:
    """Represents a namespace package's path.  It uses the module name
    to find its parent module, and kutoka there it looks up the parent's
    __path__.  When this changes, the module's own path is recomputed,
    using path_finder.  For top-level modules, the parent module's path
    is sys.path."""

    eleza __init__(self, name, path, path_finder):
        self._name = name
        self._path = path
        self._last_parent_path = tuple(self._get_parent_path())
        self._path_finder = path_finder

    eleza _find_parent_path_names(self):
        """Returns a tuple of (parent-module-name, parent-path-attr-name)"""
        parent, dot, me = self._name.rpartition('.')
        ikiwa dot == '':
            # This is a top-level module. sys.path contains the parent path.
            rudisha 'sys', 'path'
        # Not a top-level module. parent-module.__path__ contains the
        #  parent path.
        rudisha parent, '__path__'

    eleza _get_parent_path(self):
        parent_module_name, path_attr_name = self._find_parent_path_names()
        rudisha getattr(sys.modules[parent_module_name], path_attr_name)

    eleza _recalculate(self):
        # If the parent's path has changed, recalculate _path
        parent_path = tuple(self._get_parent_path()) # Make a copy
        ikiwa parent_path != self._last_parent_path:
            spec = self._path_finder(self._name, parent_path)
            # Note that no changes are made ikiwa a loader is returned, but we
            #  do remember the new parent path
            ikiwa spec is not None and spec.loader is None:
                ikiwa spec.submodule_search_locations:
                    self._path = spec.submodule_search_locations
            self._last_parent_path = parent_path     # Save the copy
        rudisha self._path

    eleza __iter__(self):
        rudisha iter(self._recalculate())

    eleza __getitem__(self, index):
        rudisha self._recalculate()[index]

    eleza __setitem__(self, index, path):
        self._path[index] = path

    eleza __len__(self):
        rudisha len(self._recalculate())

    eleza __repr__(self):
        rudisha '_NamespacePath({!r})'.format(self._path)

    eleza __contains__(self, item):
        rudisha item in self._recalculate()

    eleza append(self, item):
        self._path.append(item)


# We use this exclusively in module_kutoka_spec() for backward-compatibility.
kundi _NamespaceLoader:
    eleza __init__(self, name, path, path_finder):
        self._path = _NamespacePath(name, path, path_finder)

    @classmethod
    eleza module_repr(cls, module):
        """Return repr for the module.

        The method is deprecated.  The agiza machinery does the job itself.

        """
        rudisha '<module {!r} (namespace)>'.format(module.__name__)

    eleza is_package(self, fullname):
        rudisha True

    eleza get_source(self, fullname):
        rudisha ''

    eleza get_code(self, fullname):
        rudisha compile('', '<string>', 'exec', dont_inherit=True)

    eleza create_module(self, spec):
        """Use default semantics for module creation."""

    eleza exec_module(self, module):
        pass

    eleza load_module(self, fullname):
        """Load a namespace module.

        This method is deprecated.  Use exec_module() instead.

        """
        # The agiza system never calls this method.
        _bootstrap._verbose_message('namespace module loaded with path {!r}',
                                    self._path)
        rudisha _bootstrap._load_module_shim(self, fullname)


# Finders #####################################################################

kundi PathFinder:

    """Meta path finder for sys.path and package __path__ attributes."""

    @classmethod
    eleza invalidate_caches(cls):
        """Call the invalidate_caches() method on all path entry finders
        stored in sys.path_importer_caches (where implemented)."""
        for name, finder in list(sys.path_importer_cache.items()):
            ikiwa finder is None:
                del sys.path_importer_cache[name]
            elikiwa hasattr(finder, 'invalidate_caches'):
                finder.invalidate_caches()

    @classmethod
    eleza _path_hooks(cls, path):
        """Search sys.path_hooks for a finder for 'path'."""
        ikiwa sys.path_hooks is not None and not sys.path_hooks:
            _warnings.warn('sys.path_hooks is empty', ImportWarning)
        for hook in sys.path_hooks:
            try:
                rudisha hook(path)
            except ImportError:
                continue
        else:
            rudisha None

    @classmethod
    eleza _path_importer_cache(cls, path):
        """Get the finder for the path entry kutoka sys.path_importer_cache.

        If the path entry is not in the cache, find the appropriate finder
        and cache it. If no finder is available, store None.

        """
        ikiwa path == '':
            try:
                path = _os.getcwd()
            except FileNotFoundError:
                # Don't cache the failure as the cwd can easily change to
                # a valid directory later on.
                rudisha None
        try:
            finder = sys.path_importer_cache[path]
        except KeyError:
            finder = cls._path_hooks(path)
            sys.path_importer_cache[path] = finder
        rudisha finder

    @classmethod
    eleza _legacy_get_spec(cls, fullname, finder):
        # This would be a good place for a DeprecationWarning if
        # we ended up going that route.
        ikiwa hasattr(finder, 'find_loader'):
            loader, portions = finder.find_loader(fullname)
        else:
            loader = finder.find_module(fullname)
            portions = []
        ikiwa loader is not None:
            rudisha _bootstrap.spec_kutoka_loader(fullname, loader)
        spec = _bootstrap.ModuleSpec(fullname, None)
        spec.submodule_search_locations = portions
        rudisha spec

    @classmethod
    eleza _get_spec(cls, fullname, path, target=None):
        """Find the loader or namespace_path for this module/package name."""
        # If this ends up being a namespace package, namespace_path is
        #  the list of paths that will become its __path__
        namespace_path = []
        for entry in path:
            ikiwa not isinstance(entry, (str, bytes)):
                continue
            finder = cls._path_importer_cache(entry)
            ikiwa finder is not None:
                ikiwa hasattr(finder, 'find_spec'):
                    spec = finder.find_spec(fullname, target)
                else:
                    spec = cls._legacy_get_spec(fullname, finder)
                ikiwa spec is None:
                    continue
                ikiwa spec.loader is not None:
                    rudisha spec
                portions = spec.submodule_search_locations
                ikiwa portions is None:
                    raise ImportError('spec missing loader')
                # This is possibly part of a namespace package.
                #  Remember these path entries (ikiwa any) for when we
                #  create a namespace package, and continue iterating
                #  on path.
                namespace_path.extend(portions)
        else:
            spec = _bootstrap.ModuleSpec(fullname, None)
            spec.submodule_search_locations = namespace_path
            rudisha spec

    @classmethod
    eleza find_spec(cls, fullname, path=None, target=None):
        """Try to find a spec for 'fullname' on sys.path or 'path'.

        The search is based on sys.path_hooks and sys.path_importer_cache.
        """
        ikiwa path is None:
            path = sys.path
        spec = cls._get_spec(fullname, path, target)
        ikiwa spec is None:
            rudisha None
        elikiwa spec.loader is None:
            namespace_path = spec.submodule_search_locations
            ikiwa namespace_path:
                # We found at least one namespace path.  Return a spec which
                # can create the namespace package.
                spec.origin = None
                spec.submodule_search_locations = _NamespacePath(fullname, namespace_path, cls._get_spec)
                rudisha spec
            else:
                rudisha None
        else:
            rudisha spec

    @classmethod
    eleza find_module(cls, fullname, path=None):
        """find the module on sys.path or 'path' based on sys.path_hooks and
        sys.path_importer_cache.

        This method is deprecated.  Use find_spec() instead.

        """
        spec = cls.find_spec(fullname, path)
        ikiwa spec is None:
            rudisha None
        rudisha spec.loader

    @classmethod
    eleza find_distributions(cls, *args, **kwargs):
        """
        Find distributions.

        Return an iterable of all Distribution instances capable of
        loading the metadata for packages matching ``context.name``
        (or all names ikiwa ``None`` indicated) along the paths in the list
        of directories ``context.path``.
        """
        kutoka importlib.metadata agiza MetadataPathFinder
        rudisha MetadataPathFinder.find_distributions(*args, **kwargs)


kundi FileFinder:

    """File-based finder.

    Interactions with the file system are cached for performance, being
    refreshed when the directory the finder is handling has been modified.

    """

    eleza __init__(self, path, *loader_details):
        """Initialize with the path to search on and a variable number of
        2-tuples containing the loader and the file suffixes the loader
        recognizes."""
        loaders = []
        for loader, suffixes in loader_details:
            loaders.extend((suffix, loader) for suffix in suffixes)
        self._loaders = loaders
        # Base (directory) path
        self.path = path or '.'
        self._path_mtime = -1
        self._path_cache = set()
        self._relaxed_path_cache = set()

    eleza invalidate_caches(self):
        """Invalidate the directory mtime."""
        self._path_mtime = -1

    find_module = _find_module_shim

    eleza find_loader(self, fullname):
        """Try to find a loader for the specified module, or the namespace
        package portions. Returns (loader, list-of-portions).

        This method is deprecated.  Use find_spec() instead.

        """
        spec = self.find_spec(fullname)
        ikiwa spec is None:
            rudisha None, []
        rudisha spec.loader, spec.submodule_search_locations or []

    eleza _get_spec(self, loader_class, fullname, path, smsl, target):
        loader = loader_class(fullname, path)
        rudisha spec_kutoka_file_location(fullname, path, loader=loader,
                                       submodule_search_locations=smsl)

    eleza find_spec(self, fullname, target=None):
        """Try to find a spec for the specified module.

        Returns the matching spec, or None ikiwa not found.
        """
        is_namespace = False
        tail_module = fullname.rpartition('.')[2]
        try:
            mtime = _path_stat(self.path or _os.getcwd()).st_mtime
        except OSError:
            mtime = -1
        ikiwa mtime != self._path_mtime:
            self._fill_cache()
            self._path_mtime = mtime
        # tail_module keeps the original casing, for __file__ and friends
        ikiwa _relax_case():
            cache = self._relaxed_path_cache
            cache_module = tail_module.lower()
        else:
            cache = self._path_cache
            cache_module = tail_module
        # Check ikiwa the module is the name of a directory (and thus a package).
        ikiwa cache_module in cache:
            base_path = _path_join(self.path, tail_module)
            for suffix, loader_kundi in self._loaders:
                init_filename = '__init__' + suffix
                full_path = _path_join(base_path, init_filename)
                ikiwa _path_isfile(full_path):
                    rudisha self._get_spec(loader_class, fullname, full_path, [base_path], target)
            else:
                # If a namespace package, rudisha the path ikiwa we don't
                #  find a module in the next section.
                is_namespace = _path_isdir(base_path)
        # Check for a file w/ a proper suffix exists.
        for suffix, loader_kundi in self._loaders:
            full_path = _path_join(self.path, tail_module + suffix)
            _bootstrap._verbose_message('trying {}', full_path, verbosity=2)
            ikiwa cache_module + suffix in cache:
                ikiwa _path_isfile(full_path):
                    rudisha self._get_spec(loader_class, fullname, full_path,
                                          None, target)
        ikiwa is_namespace:
            _bootstrap._verbose_message('possible namespace for {}', base_path)
            spec = _bootstrap.ModuleSpec(fullname, None)
            spec.submodule_search_locations = [base_path]
            rudisha spec
        rudisha None

    eleza _fill_cache(self):
        """Fill the cache of potential modules and packages for this directory."""
        path = self.path
        try:
            contents = _os.listdir(path or _os.getcwd())
        except (FileNotFoundError, PermissionError, NotADirectoryError):
            # Directory has either been removed, turned into a file, or made
            # unreadable.
            contents = []
        # We store two cached versions, to handle runtime changes of the
        # PYTHONCASEOK environment variable.
        ikiwa not sys.platform.startswith('win'):
            self._path_cache = set(contents)
        else:
            # Windows users can agiza modules with case-insensitive file
            # suffixes (for legacy reasons). Make the suffix lowercase here
            # so it's done once instead of for every agiza. This is safe as
            # the specified suffixes to check against are always specified in a
            # case-sensitive manner.
            lower_suffix_contents = set()
            for item in contents:
                name, dot, suffix = item.partition('.')
                ikiwa dot:
                    new_name = '{}.{}'.format(name, suffix.lower())
                else:
                    new_name = name
                lower_suffix_contents.add(new_name)
            self._path_cache = lower_suffix_contents
        ikiwa sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):
            self._relaxed_path_cache = {fn.lower() for fn in contents}

    @classmethod
    eleza path_hook(cls, *loader_details):
        """A kundi method which returns a closure to use on sys.path_hook
        which will rudisha an instance using the specified loaders and the path
        called on the closure.

        If the path called on the closure is not a directory, ImportError is
        raised.

        """
        eleza path_hook_for_FileFinder(path):
            """Path hook for importlib.machinery.FileFinder."""
            ikiwa not _path_isdir(path):
                raise ImportError('only directories are supported', path=path)
            rudisha cls(path, *loader_details)

        rudisha path_hook_for_FileFinder

    eleza __repr__(self):
        rudisha 'FileFinder({!r})'.format(self.path)


# Import setup ###############################################################

eleza _fix_up_module(ns, name, pathname, cpathname=None):
    # This function is used by PyImport_ExecCodeModuleObject().
    loader = ns.get('__loader__')
    spec = ns.get('__spec__')
    ikiwa not loader:
        ikiwa spec:
            loader = spec.loader
        elikiwa pathname == cpathname:
            loader = SourcelessFileLoader(name, pathname)
        else:
            loader = SourceFileLoader(name, pathname)
    ikiwa not spec:
        spec = spec_kutoka_file_location(name, pathname, loader=loader)
    try:
        ns['__spec__'] = spec
        ns['__loader__'] = loader
        ns['__file__'] = pathname
        ns['__cached__'] = cpathname
    except Exception:
        # Not agizaant enough to report.
        pass


eleza _get_supported_file_loaders():
    """Returns a list of file-based module loaders.

    Each item is a tuple (loader, suffixes).
    """
    extensions = ExtensionFileLoader, _imp.extension_suffixes()
    source = SourceFileLoader, SOURCE_SUFFIXES
    bytecode = SourcelessFileLoader, BYTECODE_SUFFIXES
    rudisha [extensions, source, bytecode]


eleza _setup(_bootstrap_module):
    """Setup the path-based importers for importlib by agizaing needed
    built-in modules and injecting them into the global namespace.

    Other components are extracted kutoka the core bootstrap module.

    """
    global sys, _imp, _bootstrap
    _bootstrap = _bootstrap_module
    sys = _bootstrap.sys
    _imp = _bootstrap._imp

    # Directly load built-in modules needed during bootstrap.
    self_module = sys.modules[__name__]
    for builtin_name in ('_io', '_warnings', 'builtins', 'marshal'):
        ikiwa builtin_name not in sys.modules:
            builtin_module = _bootstrap._builtin_kutoka_name(builtin_name)
        else:
            builtin_module = sys.modules[builtin_name]
        setattr(self_module, builtin_name, builtin_module)

    # Directly load the os module (needed during bootstrap).
    os_details = ('posix', ['/']), ('nt', ['\\', '/'])
    for builtin_os, path_separators in os_details:
        # Assumption made in _path_join()
        assert all(len(sep) == 1 for sep in path_separators)
        path_sep = path_separators[0]
        ikiwa builtin_os in sys.modules:
            os_module = sys.modules[builtin_os]
            break
        else:
            try:
                os_module = _bootstrap._builtin_kutoka_name(builtin_os)
                break
            except ImportError:
                continue
    else:
        raise ImportError('importlib requires posix or nt')
    setattr(self_module, '_os', os_module)
    setattr(self_module, 'path_sep', path_sep)
    setattr(self_module, 'path_separators', ''.join(path_separators))
    setattr(self_module, '_pathseps_with_colon', {f':{s}' for s in path_separators})

    # Directly load the _thread module (needed during bootstrap).
    thread_module = _bootstrap._builtin_kutoka_name('_thread')
    setattr(self_module, '_thread', thread_module)

    # Directly load the _weakref module (needed during bootstrap).
    weakref_module = _bootstrap._builtin_kutoka_name('_weakref')
    setattr(self_module, '_weakref', weakref_module)

    # Directly load the winreg module (needed during bootstrap).
    ikiwa builtin_os == 'nt':
        winreg_module = _bootstrap._builtin_kutoka_name('winreg')
        setattr(self_module, '_winreg', winreg_module)

    # Constants
    setattr(self_module, '_relax_case', _make_relax_case())
    EXTENSION_SUFFIXES.extend(_imp.extension_suffixes())
    ikiwa builtin_os == 'nt':
        SOURCE_SUFFIXES.append('.pyw')
        ikiwa '_d.pyd' in EXTENSION_SUFFIXES:
            WindowsRegistryFinder.DEBUG_BUILD = True


eleza _install(_bootstrap_module):
    """Install the path-based agiza components."""
    _setup(_bootstrap_module)
    supported_loaders = _get_supported_file_loaders()
    sys.path_hooks.extend([FileFinder.path_hook(*supported_loaders)])
    sys.meta_path.append(PathFinder)
