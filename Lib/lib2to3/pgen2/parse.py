# Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
# Licensed to PSF under a Contributor Agreement.

"""Parser engine kila the grammar tables generated by pgen.

The grammar table must be loaded first.

See Parser/parser.c kwenye the Python distribution kila additional info on
how this parsing engine works.

"""

# Local agizas
kutoka . agiza token

kundi ParseError(Exception):
    """Exception to signal the parser ni stuck."""

    eleza __init__(self, msg, type, value, context):
        Exception.__init__(self, "%s: type=%r, value=%r, context=%r" %
                           (msg, type, value, context))
        self.msg = msg
        self.type = type
        self.value = value
        self.context = context

    eleza __reduce__(self):
        rudisha type(self), (self.msg, self.type, self.value, self.context)

kundi Parser(object):
    """Parser engine.

    The proper usage sequence is:

    p = Parser(grammar, [converter])  # create instance
    p.setup([start])                  # prepare kila parsing
    <kila each input token>:
        ikiwa p.addtoken(...):           # parse a token; may ashiria ParseError
            koma
    root = p.rootnode                 # root of abstract syntax tree

    A Parser instance may be reused by calling setup() repeatedly.

    A Parser instance contains state pertaining to the current token
    sequence, na should sio be used concurrently by different threads
    to parse separate token sequences.

    See driver.py kila how to get input tokens by tokenizing a file or
    string.

    Parsing ni complete when addtoken() rudishas Kweli; the root of the
    abstract syntax tree can then be retrieved kutoka the rootnode
    instance variable.  When a syntax error occurs, addtoken() ashirias
    the ParseError exception.  There ni no error recovery; the parser
    cannot be used after a syntax error was reported (but it can be
    reinitialized by calling setup()).

    """

    eleza __init__(self, grammar, convert=Tupu):
        """Constructor.

        The grammar argument ni a grammar.Grammar instance; see the
        grammar module kila more information.

        The parser ni sio ready yet kila parsing; you must call the
        setup() method to get it started.

        The optional convert argument ni a function mapping concrete
        syntax tree nodes to abstract syntax tree nodes.  If not
        given, no conversion ni done na the syntax tree produced is
        the concrete syntax tree.  If given, it must be a function of
        two arguments, the first being the grammar (a grammar.Grammar
        instance), na the second being the concrete syntax tree node
        to be converted.  The syntax tree ni converted kutoka the bottom
        up.

        A concrete syntax tree node ni a (type, value, context, nodes)
        tuple, where type ni the node type (a token ama symbol number),
        value ni Tupu kila symbols na a string kila tokens, context is
        Tupu ama an opaque value used kila error reporting (typically a
        (lineno, offset) pair), na nodes ni a list of children for
        symbols, na Tupu kila tokens.

        An abstract syntax tree node may be anything; this ni entirely
        up to the converter function.

        """
        self.grammar = grammar
        self.convert = convert ama (lambda grammar, node: node)

    eleza setup(self, start=Tupu):
        """Prepare kila parsing.

        This *must* be called before starting to parse.

        The optional argument ni an alternative start symbol; it
        defaults to the grammar's start symbol.

        You can use a Parser instance to parse any number of programs;
        each time you call setup() the parser ni reset to an initial
        state determined by the (implicit ama explicit) start symbol.

        """
        ikiwa start ni Tupu:
            start = self.grammar.start
        # Each stack entry ni a tuple: (dfa, state, node).
        # A node ni a tuple: (type, value, context, children),
        # where children ni a list of nodes ama Tupu, na context may be Tupu.
        newnode = (start, Tupu, Tupu, [])
        stackentry = (self.grammar.dfas[start], 0, newnode)
        self.stack = [stackentry]
        self.rootnode = Tupu
        self.used_names = set() # Aliased to self.rootnode.used_names kwenye pop()

    eleza addtoken(self, type, value, context):
        """Add a token; rudisha Kweli iff this ni the end of the program."""
        # Map kutoka token to label
        ilabel = self.classify(type, value, context)
        # Loop until the token ni shifted; may ashiria exceptions
        wakati Kweli:
            dfa, state, node = self.stack[-1]
            states, first = dfa
            arcs = states[state]
            # Look kila a state ukijumuisha this label
            kila i, newstate kwenye arcs:
                t, v = self.grammar.labels[i]
                ikiwa ilabel == i:
                    # Look it up kwenye the list of labels
                    assert t < 256
                    # Shift a token; we're done ukijumuisha it
                    self.shift(type, value, newstate, context)
                    # Pop wakati we are kwenye an accept-only state
                    state = newstate
                    wakati states[state] == [(0, state)]:
                        self.pop()
                        ikiwa sio self.stack:
                            # Done parsing!
                            rudisha Kweli
                        dfa, state, node = self.stack[-1]
                        states, first = dfa
                    # Done ukijumuisha this token
                    rudisha Uongo
                lasivyo t >= 256:
                    # See ikiwa it's a symbol na ikiwa we're kwenye its first set
                    itsdfa = self.grammar.dfas[t]
                    itsstates, itsfirst = itsdfa
                    ikiwa ilabel kwenye itsfirst:
                        # Push a symbol
                        self.push(t, self.grammar.dfas[t], newstate, context)
                        koma # To endelea the outer wakati loop
            isipokua:
                ikiwa (0, state) kwenye arcs:
                    # An accepting state, pop it na try something else
                    self.pop()
                    ikiwa sio self.stack:
                        # Done parsing, but another token ni input
                        ashiria ParseError("too much input",
                                         type, value, context)
                isipokua:
                    # No success finding a transition
                    ashiria ParseError("bad input", type, value, context)

    eleza classify(self, type, value, context):
        """Turn a token into a label.  (Internal)"""
        ikiwa type == token.NAME:
            # Keep a listing of all used names
            self.used_names.add(value)
            # Check kila reserved words
            ilabel = self.grammar.keywords.get(value)
            ikiwa ilabel ni sio Tupu:
                rudisha ilabel
        ilabel = self.grammar.tokens.get(type)
        ikiwa ilabel ni Tupu:
            ashiria ParseError("bad token", type, value, context)
        rudisha ilabel

    eleza shift(self, type, value, newstate, context):
        """Shift a token.  (Internal)"""
        dfa, state, node = self.stack[-1]
        newnode = (type, value, context, Tupu)
        newnode = self.convert(self.grammar, newnode)
        ikiwa newnode ni sio Tupu:
            node[-1].append(newnode)
        self.stack[-1] = (dfa, newstate, node)

    eleza push(self, type, newdfa, newstate, context):
        """Push a nonterminal.  (Internal)"""
        dfa, state, node = self.stack[-1]
        newnode = (type, Tupu, context, [])
        self.stack[-1] = (dfa, newstate, node)
        self.stack.append((newdfa, 0, newnode))

    eleza pop(self):
        """Pop a nonterminal.  (Internal)"""
        popdfa, popstate, popnode = self.stack.pop()
        newnode = self.convert(self.grammar, popnode)
        ikiwa newnode ni sio Tupu:
            ikiwa self.stack:
                dfa, state, node = self.stack[-1]
                node[-1].append(newnode)
            isipokua:
                self.rootnode = newnode
                self.rootnode.used_names = self.used_names
