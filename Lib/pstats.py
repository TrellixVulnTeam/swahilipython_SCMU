"""Class for printing reports on profiled python code."""

# Written by James Roskind
# Based on prior profile module by Sjoerd Mullender...
#   which was hacked somewhat by: Guido van Rossum

# Copyright Disney Enterprises, Inc.  All Rights Reserved.
# Licensed to PSF under a Contributor Agreement
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied.  See the License for the specific language
# governing permissions and limitations under the License.


agiza sys
agiza os
agiza time
agiza marshal
agiza re
kutoka enum agiza Enum
kutoka functools agiza cmp_to_key

__all__ = ["Stats", "SortKey"]


kundi SortKey(str, Enum):
    CALLS = 'calls', 'ncalls'
    CUMULATIVE = 'cumulative', 'cumtime'
    FILENAME = 'filename', 'module'
    LINE = 'line'
    NAME = 'name'
    NFL = 'nfl'
    PCALLS = 'pcalls'
    STDNAME = 'stdname'
    TIME = 'time', 'tottime'

    eleza __new__(cls, *values):
        obj = str.__new__(cls)

        obj._value_ = values[0]
        for other_value in values[1:]:
            cls._value2member_map_[other_value] = obj
        obj._all_values = values
        rudisha obj


kundi Stats:
    """This kundi is used for creating reports kutoka data generated by the
    Profile class.  It is a "friend" of that class, and agizas data either
    by direct access to members of Profile class, or by reading in a dictionary
    that was emitted (via marshal) kutoka the Profile class.

    The big change kutoka the previous Profiler (in terms of raw functionality)
    is that an "add()" method has been provided to combine Stats kutoka
    several distinct profile runs.  Both the constructor and the add()
    method now take arbitrarily many file names as arguments.

    All the print methods now take an argument that indicates how many lines
    to print.  If the arg is a floating point number between 0 and 1.0, then
    it is taken as a decimal percentage of the available lines to be printed
    (e.g., .1 means print 10% of all available lines).  If it is an integer,
    it is taken to mean the number of lines of data that you wish to have
    printed.

    The sort_stats() method now processes some additional options (i.e., in
    addition to the old -1, 0, 1, or 2 that are respectively interpreted as
    'stdname', 'calls', 'time', and 'cumulative').  It takes either an
    arbitrary number of quoted strings or SortKey enum to select the sort
    order.

    For example sort_stats('time', 'name') or sort_stats(SortKey.TIME,
    SortKey.NAME) sorts on the major key of 'internal function time', and on
    the minor key of 'the name of the function'.  Look at the two tables in
    sort_stats() and get_sort_arg_defs(self) for more examples.

    All methods rudisha self, so you can string together commands like:
        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
    """

    eleza __init__(self, *args, stream=None):
        self.stream = stream or sys.stdout
        ikiwa not len(args):
            arg = None
        else:
            arg = args[0]
            args = args[1:]
        self.init(arg)
        self.add(*args)

    eleza init(self, arg):
        self.all_callees = None  # calc only ikiwa needed
        self.files = []
        self.fcn_list = None
        self.total_tt = 0
        self.total_calls = 0
        self.prim_calls = 0
        self.max_name_len = 0
        self.top_level = set()
        self.stats = {}
        self.sort_arg_dict = {}
        self.load_stats(arg)
        try:
            self.get_top_level_stats()
        except Exception:
            andika("Invalid timing data %s" %
                  (self.files[-1] ikiwa self.files else ''), file=self.stream)
            raise

    eleza load_stats(self, arg):
        ikiwa arg is None:
            self.stats = {}
            return
        elikiwa isinstance(arg, str):
            with open(arg, 'rb') as f:
                self.stats = marshal.load(f)
            try:
                file_stats = os.stat(arg)
                arg = time.ctime(file_stats.st_mtime) + "    " + arg
            except:  # in case this is not unix
                pass
            self.files = [arg]
        elikiwa hasattr(arg, 'create_stats'):
            arg.create_stats()
            self.stats = arg.stats
            arg.stats = {}
        ikiwa not self.stats:
            raise TypeError("Cannot create or construct a %r object kutoka %r"
                            % (self.__class__, arg))
        return

    eleza get_top_level_stats(self):
        for func, (cc, nc, tt, ct, callers) in self.stats.items():
            self.total_calls += nc
            self.prim_calls  += cc
            self.total_tt    += tt
            ikiwa ("jprofile", 0, "profiler") in callers:
                self.top_level.add(func)
            ikiwa len(func_std_string(func)) > self.max_name_len:
                self.max_name_len = len(func_std_string(func))

    eleza add(self, *arg_list):
        ikiwa not arg_list:
            rudisha self
        for item in reversed(arg_list):
            ikiwa type(self) != type(item):
                item = Stats(item)
            self.files += item.files
            self.total_calls += item.total_calls
            self.prim_calls += item.prim_calls
            self.total_tt += item.total_tt
            for func in item.top_level:
                self.top_level.add(func)

            ikiwa self.max_name_len < item.max_name_len:
                self.max_name_len = item.max_name_len

            self.fcn_list = None

            for func, stat in item.stats.items():
                ikiwa func in self.stats:
                    old_func_stat = self.stats[func]
                else:
                    old_func_stat = (0, 0, 0, 0, {},)
                self.stats[func] = add_func_stats(old_func_stat, stat)
        rudisha self

    eleza dump_stats(self, filename):
        """Write the profile data to a file we know how to load back."""
        with open(filename, 'wb') as f:
            marshal.dump(self.stats, f)

    # list the tuple indices and directions for sorting,
    # along with some printable description
    sort_arg_dict_default = {
              "calls"     : (((1,-1),              ), "call count"),
              "ncalls"    : (((1,-1),              ), "call count"),
              "cumtime"   : (((3,-1),              ), "cumulative time"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "filename"  : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "primitive call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),
              "tottime"   : (((2,-1),              ), "internal time"),
              }

    eleza get_sort_arg_defs(self):
        """Expand all abbreviations that are unique."""
        ikiwa not self.sort_arg_dict:
            self.sort_arg_dict = dict = {}
            bad_list = {}
            for word, tup in self.sort_arg_dict_default.items():
                fragment = word
                while fragment:
                    ikiwa not fragment:
                        break
                    ikiwa fragment in dict:
                        bad_list[fragment] = 0
                        break
                    dict[fragment] = tup
                    fragment = fragment[:-1]
            for word in bad_list:
                del dict[word]
        rudisha self.sort_arg_dict

    eleza sort_stats(self, *field):
        ikiwa not field:
            self.fcn_list = 0
            rudisha self
        ikiwa len(field) == 1 and isinstance(field[0], int):
            # Be compatible with old profiler
            field = [ {-1: "stdname",
                       0:  "calls",
                       1:  "time",
                       2:  "cumulative"}[field[0]] ]
        elikiwa len(field) >= 2:
            for arg in field[1:]:
                ikiwa type(arg) != type(field[0]):
                    raise TypeError("Can't have mixed argument type")

        sort_arg_defs = self.get_sort_arg_defs()

        sort_tuple = ()
        self.sort_type = ""
        connector = ""
        for word in field:
            ikiwa isinstance(word, SortKey):
                word = word.value
            sort_tuple = sort_tuple + sort_arg_defs[word][0]
            self.sort_type += connector + sort_arg_defs[word][1]
            connector = ", "

        stats_list = []
        for func, (cc, nc, tt, ct, callers) in self.stats.items():
            stats_list.append((cc, nc, tt, ct) + func +
                              (func_std_string(func), func))

        stats_list.sort(key=cmp_to_key(TupleComp(sort_tuple).compare))

        self.fcn_list = fcn_list = []
        for tuple in stats_list:
            fcn_list.append(tuple[-1])
        rudisha self

    eleza reverse_order(self):
        ikiwa self.fcn_list:
            self.fcn_list.reverse()
        rudisha self

    eleza strip_dirs(self):
        oldstats = self.stats
        self.stats = newstats = {}
        max_name_len = 0
        for func, (cc, nc, tt, ct, callers) in oldstats.items():
            newfunc = func_strip_path(func)
            ikiwa len(func_std_string(newfunc)) > max_name_len:
                max_name_len = len(func_std_string(newfunc))
            newcallers = {}
            for func2, caller in callers.items():
                newcallers[func_strip_path(func2)] = caller

            ikiwa newfunc in newstats:
                newstats[newfunc] = add_func_stats(
                                        newstats[newfunc],
                                        (cc, nc, tt, ct, newcallers))
            else:
                newstats[newfunc] = (cc, nc, tt, ct, newcallers)
        old_top = self.top_level
        self.top_level = new_top = set()
        for func in old_top:
            new_top.add(func_strip_path(func))

        self.max_name_len = max_name_len

        self.fcn_list = None
        self.all_callees = None
        rudisha self

    eleza calc_callees(self):
        ikiwa self.all_callees:
            return
        self.all_callees = all_callees = {}
        for func, (cc, nc, tt, ct, callers) in self.stats.items():
            ikiwa not func in all_callees:
                all_callees[func] = {}
            for func2, caller in callers.items():
                ikiwa not func2 in all_callees:
                    all_callees[func2] = {}
                all_callees[func2][func]  = caller
        return

    #******************************************************************
    # The following functions support actual printing of reports
    #******************************************************************

    # Optional "amount" is either a line count, or a percentage of lines.

    eleza eval_print_amount(self, sel, list, msg):
        new_list = list
        ikiwa isinstance(sel, str):
            try:
                rex = re.compile(sel)
            except re.error:
                msg += "   <Invalid regular expression %r>\n" % sel
                rudisha new_list, msg
            new_list = []
            for func in list:
                ikiwa rex.search(func_std_string(func)):
                    new_list.append(func)
        else:
            count = len(list)
            ikiwa isinstance(sel, float) and 0.0 <= sel < 1.0:
                count = int(count * sel + .5)
                new_list = list[:count]
            elikiwa isinstance(sel, int) and 0 <= sel < count:
                count = sel
                new_list = list[:count]
        ikiwa len(list) != len(new_list):
            msg += "   List reduced kutoka %r to %r due to restriction <%r>\n" % (
                len(list), len(new_list), sel)

        rudisha new_list, msg

    eleza get_print_list(self, sel_list):
        width = self.max_name_len
        ikiwa self.fcn_list:
            stat_list = self.fcn_list[:]
            msg = "   Ordered by: " + self.sort_type + '\n'
        else:
            stat_list = list(self.stats.keys())
            msg = "   Random listing order was used\n"

        for selection in sel_list:
            stat_list, msg = self.eval_print_amount(selection, stat_list, msg)

        count = len(stat_list)

        ikiwa not stat_list:
            rudisha 0, stat_list
        andika(msg, file=self.stream)
        ikiwa count < len(self.stats):
            width = 0
            for func in stat_list:
                ikiwa  len(func_std_string(func)) > width:
                    width = len(func_std_string(func))
        rudisha width+2, stat_list

    eleza print_stats(self, *amount):
        for filename in self.files:
            andika(filename, file=self.stream)
        ikiwa self.files:
            andika(file=self.stream)
        indent = ' ' * 8
        for func in self.top_level:
            andika(indent, func_get_function_name(func), file=self.stream)

        andika(indent, self.total_calls, "function calls", end=' ', file=self.stream)
        ikiwa self.total_calls != self.prim_calls:
            andika("(%d primitive calls)" % self.prim_calls, end=' ', file=self.stream)
        andika("in %.3f seconds" % self.total_tt, file=self.stream)
        andika(file=self.stream)
        width, list = self.get_print_list(amount)
        ikiwa list:
            self.print_title()
            for func in list:
                self.print_line(func)
            andika(file=self.stream)
            andika(file=self.stream)
        rudisha self

    eleza print_callees(self, *amount):
        width, list = self.get_print_list(amount)
        ikiwa list:
            self.calc_callees()

            self.print_call_heading(width, "called...")
            for func in list:
                ikiwa func in self.all_callees:
                    self.print_call_line(width, func, self.all_callees[func])
                else:
                    self.print_call_line(width, func, {})
            andika(file=self.stream)
            andika(file=self.stream)
        rudisha self

    eleza print_callers(self, *amount):
        width, list = self.get_print_list(amount)
        ikiwa list:
            self.print_call_heading(width, "was called by...")
            for func in list:
                cc, nc, tt, ct, callers = self.stats[func]
                self.print_call_line(width, func, callers, "<-")
            andika(file=self.stream)
            andika(file=self.stream)
        rudisha self

    eleza print_call_heading(self, name_size, column_title):
        andika("Function ".ljust(name_size) + column_title, file=self.stream)
        # print sub-header only ikiwa we have new-style callers
        subheader = False
        for cc, nc, tt, ct, callers in self.stats.values():
            ikiwa callers:
                value = next(iter(callers.values()))
                subheader = isinstance(value, tuple)
                break
        ikiwa subheader:
            andika(" "*name_size + "    ncalls  tottime  cumtime", file=self.stream)

    eleza print_call_line(self, name_size, source, call_dict, arrow="->"):
        andika(func_std_string(source).ljust(name_size) + arrow, end=' ', file=self.stream)
        ikiwa not call_dict:
            andika(file=self.stream)
            return
        clist = sorted(call_dict.keys())
        indent = ""
        for func in clist:
            name = func_std_string(func)
            value = call_dict[func]
            ikiwa isinstance(value, tuple):
                nc, cc, tt, ct = value
                ikiwa nc != cc:
                    substats = '%d/%d' % (nc, cc)
                else:
                    substats = '%d' % (nc,)
                substats = '%s %s %s  %s' % (substats.rjust(7+2*len(indent)),
                                             f8(tt), f8(ct), name)
                left_width = name_size + 1
            else:
                substats = '%s(%r) %s' % (name, value, f8(self.stats[func][3]))
                left_width = name_size + 3
            andika(indent*left_width + substats, file=self.stream)
            indent = " "

    eleza print_title(self):
        andika('   ncalls  tottime  percall  cumtime  percall', end=' ', file=self.stream)
        andika('filename:lineno(function)', file=self.stream)

    eleza print_line(self, func):  # hack: should print percentages
        cc, nc, tt, ct, callers = self.stats[func]
        c = str(nc)
        ikiwa nc != cc:
            c = c + '/' + str(cc)
        andika(c.rjust(9), end=' ', file=self.stream)
        andika(f8(tt), end=' ', file=self.stream)
        ikiwa nc == 0:
            andika(' '*8, end=' ', file=self.stream)
        else:
            andika(f8(tt/nc), end=' ', file=self.stream)
        andika(f8(ct), end=' ', file=self.stream)
        ikiwa cc == 0:
            andika(' '*8, end=' ', file=self.stream)
        else:
            andika(f8(ct/cc), end=' ', file=self.stream)
        andika(func_std_string(func), file=self.stream)

kundi TupleComp:
    """This kundi provides a generic function for comparing any two tuples.
    Each instance records a list of tuple-indices (kutoka most significant
    to least significant), and sort direction (ascending or decending) for
    each tuple-index.  The compare functions can then be used as the function
    argument to the system sort() function when a list of tuples need to be
    sorted in the instances order."""

    eleza __init__(self, comp_select_list):
        self.comp_select_list = comp_select_list

    eleza compare (self, left, right):
        for index, direction in self.comp_select_list:
            l = left[index]
            r = right[index]
            ikiwa l < r:
                rudisha -direction
            ikiwa l > r:
                rudisha direction
        rudisha 0


#**************************************************************************
# func_name is a triple (file:string, line:int, name:string)

eleza func_strip_path(func_name):
    filename, line, name = func_name
    rudisha os.path.basename(filename), line, name

eleza func_get_function_name(func):
    rudisha func[2]

eleza func_std_string(func_name): # match what old profile produced
    ikiwa func_name[:2] == ('~', 0):
        # special case for built-in functions
        name = func_name[2]
        ikiwa name.startswith('<') and name.endswith('>'):
            rudisha '{%s}' % name[1:-1]
        else:
            rudisha name
    else:
        rudisha "%s:%d(%s)" % func_name

#**************************************************************************
# The following functions combine statistics for pairs functions.
# The bulk of the processing involves correctly handling "call" lists,
# such as callers and callees.
#**************************************************************************

eleza add_func_stats(target, source):
    """Add together all the stats for two profile entries."""
    cc, nc, tt, ct, callers = source
    t_cc, t_nc, t_tt, t_ct, t_callers = target
    rudisha (cc+t_cc, nc+t_nc, tt+t_tt, ct+t_ct,
              add_callers(t_callers, callers))

eleza add_callers(target, source):
    """Combine two caller lists in a single list."""
    new_callers = {}
    for func, caller in target.items():
        new_callers[func] = caller
    for func, caller in source.items():
        ikiwa func in new_callers:
            ikiwa isinstance(caller, tuple):
                # format used by cProfile
                new_callers[func] = tuple(i + j for i, j in zip(caller, new_callers[func]))
            else:
                # format used by profile
                new_callers[func] += caller
        else:
            new_callers[func] = caller
    rudisha new_callers

eleza count_calls(callers):
    """Sum the caller statistics to get total number of calls received."""
    nc = 0
    for calls in callers.values():
        nc += calls
    rudisha nc

#**************************************************************************
# The following functions support printing of reports
#**************************************************************************

eleza f8(x):
    rudisha "%8.3f" % x

#**************************************************************************
# Statistics browser added by ESR, April 2001
#**************************************************************************

ikiwa __name__ == '__main__':
    agiza cmd
    try:
        agiza readline
    except ImportError:
        pass

    kundi ProfileBrowser(cmd.Cmd):
        eleza __init__(self, profile=None):
            cmd.Cmd.__init__(self)
            self.prompt = "% "
            self.stats = None
            self.stream = sys.stdout
            ikiwa profile is not None:
                self.do_read(profile)

        eleza generic(self, fn, line):
            args = line.split()
            processed = []
            for term in args:
                try:
                    processed.append(int(term))
                    continue
                except ValueError:
                    pass
                try:
                    frac = float(term)
                    ikiwa frac > 1 or frac < 0:
                        andika("Fraction argument must be in [0, 1]", file=self.stream)
                        continue
                    processed.append(frac)
                    continue
                except ValueError:
                    pass
                processed.append(term)
            ikiwa self.stats:
                getattr(self.stats, fn)(*processed)
            else:
                andika("No statistics object is loaded.", file=self.stream)
            rudisha 0
        eleza generic_help(self):
            andika("Arguments may be:", file=self.stream)
            andika("* An integer maximum number of entries to print.", file=self.stream)
            andika("* A decimal fractional number between 0 and 1, controlling", file=self.stream)
            andika("  what fraction of selected entries to print.", file=self.stream)
            andika("* A regular expression; only entries with function names", file=self.stream)
            andika("  that match it are printed.", file=self.stream)

        eleza do_add(self, line):
            ikiwa self.stats:
                try:
                    self.stats.add(line)
                except OSError as e:
                    andika("Failed to load statistics for %s: %s" % (line, e), file=self.stream)
            else:
                andika("No statistics object is loaded.", file=self.stream)
            rudisha 0
        eleza help_add(self):
            andika("Add profile info kutoka given file to current statistics object.", file=self.stream)

        eleza do_callees(self, line):
            rudisha self.generic('print_callees', line)
        eleza help_callees(self):
            andika("Print callees statistics kutoka the current stat object.", file=self.stream)
            self.generic_help()

        eleza do_callers(self, line):
            rudisha self.generic('print_callers', line)
        eleza help_callers(self):
            andika("Print callers statistics kutoka the current stat object.", file=self.stream)
            self.generic_help()

        eleza do_EOF(self, line):
            andika("", file=self.stream)
            rudisha 1
        eleza help_EOF(self):
            andika("Leave the profile browser.", file=self.stream)

        eleza do_quit(self, line):
            rudisha 1
        eleza help_quit(self):
            andika("Leave the profile browser.", file=self.stream)

        eleza do_read(self, line):
            ikiwa line:
                try:
                    self.stats = Stats(line)
                except OSError as err:
                    andika(err.args[1], file=self.stream)
                    return
                except Exception as err:
                    andika(err.__class__.__name__ + ':', err, file=self.stream)
                    return
                self.prompt = line + "% "
            elikiwa len(self.prompt) > 2:
                line = self.prompt[:-2]
                self.do_read(line)
            else:
                andika("No statistics object is current -- cannot reload.", file=self.stream)
            rudisha 0
        eleza help_read(self):
            andika("Read in profile data kutoka a specified file.", file=self.stream)
            andika("Without argument, reload the current file.", file=self.stream)

        eleza do_reverse(self, line):
            ikiwa self.stats:
                self.stats.reverse_order()
            else:
                andika("No statistics object is loaded.", file=self.stream)
            rudisha 0
        eleza help_reverse(self):
            andika("Reverse the sort order of the profiling report.", file=self.stream)

        eleza do_sort(self, line):
            ikiwa not self.stats:
                andika("No statistics object is loaded.", file=self.stream)
                return
            abbrevs = self.stats.get_sort_arg_defs()
            ikiwa line and all((x in abbrevs) for x in line.split()):
                self.stats.sort_stats(*line.split())
            else:
                andika("Valid sort keys (unique prefixes are accepted):", file=self.stream)
                for (key, value) in Stats.sort_arg_dict_default.items():
                    andika("%s -- %s" % (key, value[1]), file=self.stream)
            rudisha 0
        eleza help_sort(self):
            andika("Sort profile data according to specified keys.", file=self.stream)
            andika("(Typing `sort' without arguments lists valid keys.)", file=self.stream)
        eleza complete_sort(self, text, *args):
            rudisha [a for a in Stats.sort_arg_dict_default ikiwa a.startswith(text)]

        eleza do_stats(self, line):
            rudisha self.generic('print_stats', line)
        eleza help_stats(self):
            andika("Print statistics kutoka the current stat object.", file=self.stream)
            self.generic_help()

        eleza do_strip(self, line):
            ikiwa self.stats:
                self.stats.strip_dirs()
            else:
                andika("No statistics object is loaded.", file=self.stream)
        eleza help_strip(self):
            andika("Strip leading path information kutoka filenames in the report.", file=self.stream)

        eleza help_help(self):
            andika("Show help for a given command.", file=self.stream)

        eleza postcmd(self, stop, line):
            ikiwa stop:
                rudisha stop
            rudisha None

    ikiwa len(sys.argv) > 1:
        initprofile = sys.argv[1]
    else:
        initprofile = None
    try:
        browser = ProfileBrowser(initprofile)
        for profile in sys.argv[2:]:
            browser.do_add(profile)
        andika("Welcome to the profile statistics browser.", file=browser.stream)
        browser.cmdloop()
        andika("Goodbye.", file=browser.stream)
    except KeyboardInterrupt:
        pass

# That's all, folks.
