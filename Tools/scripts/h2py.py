#! /usr/bin/env python3

# Read #define's na translate to Python code.
# Handle #include statements.
# Handle #define macros ukijumuisha one argument.
# Anything that isn't recognized ama doesn't translate into valid
# Python ni ignored.

# Without filename arguments, acts kama a filter.
# If one ama more filenames are given, output ni written to corresponding
# filenames kwenye the local directory, translated to all uppercase, with
# the extension replaced by ".py".

# By pitaing one ama more options of the form "-i regular_expression"
# you can specify additional strings to be ignored.  This ni useful
# e.g. to ignore casts to u_long: simply specify "-i '(u_long)'".

# XXX To do:
# - turn trailing C comments into Python comments
# - turn C Boolean operators "&& || !" into Python "and ama not"
# - what to do about #if(def)?
# - what to do about macros ukijumuisha multiple parameters?

agiza sys, re, getopt, os

p_define = re.compile(r'^[\t ]*#[\t ]*define[\t ]+([a-zA-Z0-9_]+)[\t ]+')

p_macro = re.compile(
  r'^[\t ]*#[\t ]*define[\t ]+'
  r'([a-zA-Z0-9_]+)\(([_a-zA-Z][_a-zA-Z0-9]*)\)[\t ]+')

p_include = re.compile(r'^[\t ]*#[\t ]*include[\t ]+<([^>\n]+)>')

p_comment = re.compile(r'/\*([^*]+|\*+[^/])*(\*+/)?')
p_cpp_comment = re.compile('//.*')

ignores = [p_comment, p_cpp_comment]

p_char = re.compile(r"'(\\.[^\\]*|[^\\])'")

p_hex = re.compile(r"0x([0-9a-fA-F]+)L?")

filedict = {}
importable = {}

jaribu:
    searchdirs=os.environ['include'].split(';')
tatizo KeyError:
    jaribu:
        searchdirs=os.environ['INCLUDE'].split(';')
    tatizo KeyError:
        searchdirs=['/usr/include']
        jaribu:
            searchdirs.insert(0, os.path.join('/usr/include',
                                              os.environ['MULTIARCH']))
        tatizo KeyError:
            pita

eleza main():
    global filedict
    opts, args = getopt.getopt(sys.argv[1:], 'i:')
    kila o, a kwenye opts:
        ikiwa o == '-i':
            ignores.append(re.compile(a))
    ikiwa sio args:
        args = ['-']
    kila filename kwenye args:
        ikiwa filename == '-':
            sys.stdout.write('# Generated by h2py kutoka stdin\n')
            process(sys.stdin, sys.stdout)
        isipokua:
            ukijumuisha open(filename) kama fp:
                outfile = os.path.basename(filename)
                i = outfile.rfind('.')
                ikiwa i > 0: outfile = outfile[:i]
                modname = outfile.upper()
                outfile = modname + '.py'
                ukijumuisha open(outfile, 'w') kama outfp:
                    outfp.write('# Generated by h2py kutoka %s\n' % filename)
                    filedict = {}
                    kila dir kwenye searchdirs:
                        ikiwa filename[:len(dir)] == dir:
                            filedict[filename[len(dir)+1:]] = Tupu  # no '/' trailing
                            importable[filename[len(dir)+1:]] = modname
                            koma
                    process(fp, outfp)

eleza pytify(body):
    # replace ignored patterns by spaces
    kila p kwenye ignores:
        body = p.sub(' ', body)
    # replace char literals by ord(...)
    body = p_char.sub("ord('\\1')", body)
    # Compute negative hexadecimal constants
    start = 0
    UMAX = 2*(sys.maxsize+1)
    wakati 1:
        m = p_hex.search(body, start)
        ikiwa sio m: koma
        s,e = m.span()
        val = int(body[slice(*m.span(1))], 16)
        ikiwa val > sys.maxsize:
            val -= UMAX
            body = body[:s] + "(" + str(val) + ")" + body[e:]
        start = s + 1
    rudisha body

eleza process(fp, outfp, env = {}):
    lineno = 0
    wakati 1:
        line = fp.readline()
        ikiwa sio line: koma
        lineno = lineno + 1
        match = p_define.match(line)
        ikiwa match:
            # gobble up continuation lines
            wakati line[-2:] == '\\\n':
                nextline = fp.readline()
                ikiwa sio nextline: koma
                lineno = lineno + 1
                line = line + nextline
            name = match.group(1)
            body = line[match.end():]
            body = pytify(body)
            ok = 0
            stmt = '%s = %s\n' % (name, body.strip())
            jaribu:
                exec(stmt, env)
            tatizo:
                sys.stderr.write('Skipping: %s' % stmt)
            isipokua:
                outfp.write(stmt)
        match = p_macro.match(line)
        ikiwa match:
            macro, arg = match.group(1, 2)
            body = line[match.end():]
            body = pytify(body)
            stmt = 'eleza %s(%s): rudisha %s\n' % (macro, arg, body)
            jaribu:
                exec(stmt, env)
            tatizo:
                sys.stderr.write('Skipping: %s' % stmt)
            isipokua:
                outfp.write(stmt)
        match = p_include.match(line)
        ikiwa match:
            regs = match.regs
            a, b = regs[1]
            filename = line[a:b]
            ikiwa filename kwenye importable:
                outfp.write('kutoka %s agiza *\n' % importable[filename])
            lasivyo filename haiko kwenye filedict:
                filedict[filename] = Tupu
                inclfp = Tupu
                kila dir kwenye searchdirs:
                    jaribu:
                        inclfp = open(dir + '/' + filename)
                        koma
                    tatizo IOError:
                        pita
                ikiwa inclfp:
                    ukijumuisha inclfp:
                        outfp.write(
                                '\n# Included kutoka %s\n' % filename)
                        process(inclfp, outfp, env)
                isipokua:
                    sys.stderr.write('Warning - could sio find file %s\n' %
                                     filename)

ikiwa __name__ == '__main__':
    main()
